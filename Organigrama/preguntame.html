<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preg√∫ntame LAV ESTE - Mejorado v2.15 (Correcci√≥n Bucle Ubicaciones Definitiva)</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body { scroll-behavior: smooth; }
        header {
            background: linear-gradient(to right, #ffffff, #f0f9f9, #ffffff);
            color: #333; padding: 20px; text-align: center;
        }
        header h1 { font-family: 'Montserrat', sans-serif; }
        .chat-container {
            max-width: 800px; margin: 20px auto; background-color: #e0f7fa;
            border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex; flex-direction: column; height: 75vh;
            overflow: hidden;
        }
        .chat-box {
            flex-grow: 1; padding: 20px; overflow-y: auto; border-bottom: 1px solid #eee;
            background-color: #e0f7fa;
        }

        .message-wrapper {
            display: flex;
            margin-bottom: 15px;
            align-items: flex-end;
        }
        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
        }
        .message-content {
            padding: 10px 15px; border-radius: 18px;
            max-width: calc(80% - 50px);
            white-space: pre-wrap; word-wrap: break-word;
            line-height: 1.5;
        }

        .user-message-wrapper {
            justify-content: flex-end;
        }
        .user-message-wrapper .message-avatar {
            margin-left: 10px;
            order: 1;
        }
        .user-message-wrapper .message-content {
            background-color: #008080; color: white;
            border-bottom-right-radius: 5px;
            margin-left: auto;
        }

        .bot-message-wrapper .message-avatar {
            margin-right: 10px;
        }
        .bot-message-wrapper .message-content {
            background-color: #e2e8f0; color: #333;
            border-bottom-left-radius: 5px;
        }

        .typing-indicator {
            display: flex; align-items: center; margin-bottom: 15px;
            align-self: flex-start; margin-right: auto; padding: 10px 15px;
            background-color: #e2e8f0; border-radius: 18px; max-width: 80%;
        }
        .typing-indicator span {
            height: 8px; width: 8px; margin: 0 2px; background-color: #718096;
            display: block; border-radius: 50%; opacity: 0.4;
            animation: pulse 1.2s infinite ease-in-out;
        }
        .typing-indicator span:nth-child(1) { animation-delay: 0s; }
        .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes pulse { 0%, 100% { opacity: 0.3; transform: scale(0.8); } 50% { opacity: 1; transform: scale(1); } }

        .input-area { display: flex; padding: 15px; background-color: #b2ebf2; border-top: 1px solid #80deea; }
        .input-area input {
            flex-grow: 1; padding: 12px 15px; border: 1px solid #ccc;
            border-radius: 20px; margin-right: 10px; font-size: 1rem;
        }
        .input-area button {
            background-color: #005293; color: white; padding: 0 25px;
            border: none; border-radius: 20px; cursor: pointer;
            transition: background-color 0.3s ease; font-weight: 500;
            display: flex; align-items: center; justify-content: center;
        }
        .input-area button:hover { background-color: #003d6f; }
        .input-area button:disabled { background-color: #cccccc; cursor: not-allowed; }

        #clearChatButton .button-text, #helpButton .button-text {
            display: none; margin-left: 5px;
        }
        #clearChatButton:hover, #helpButton:hover {
            width: auto; padding: 0 15px; border-radius: 20px;
        }
        #clearChatButton:hover .button-text, #helpButton:hover .button-text {
            display: inline;
        }

        .help-bubbles-container {
            padding: 10px 15px; background-color: #f8f9fa;
            border-bottom: 1px solid #eee;
            max-height: 25vh;
            overflow-y: auto;
        }
        .help-bubble {
            cursor: pointer; transition: all 0.2s ease-in-out;
            font-size: 0.85rem; margin: 4px;
        }
        .help-bubble:hover { transform: translateY(-1px); }

        .help-bubbles-container .help-bubble {
             padding: 4px 10px;
             background-color: #e0f2fe;
             border: 1px solid #bae6fd;
             color: #0c4a6e;
             border-radius: 16px;
        }
        .help-bubbles-container .help-bubble:hover {
            background-color: #cce7ff; border-color: #005293; color: #005293;
        }

        .option-bubble-item {
            padding: 6px 12px;
            background-color: #dcfce7;
            border: 1px solid #86efac;
            color: #15803d;
            border-radius: 16px;
        }
        .option-bubble-item:hover {
             background-color: #bbf7d0;
             border-color: #4ade80;
             color: #166534;
        }


        .chat-box::-webkit-scrollbar, .help-bubbles-container::-webkit-scrollbar { width: 8px; }
        .chat-box::-webkit-scrollbar-track, .help-bubbles-container::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px;}
        .chat-box::-webkit-scrollbar-thumb, .help-bubbles-container::-webkit-scrollbar-thumb { background: #ccc; border-radius: 10px;}
        .chat-box::-webkit-scrollbar-thumb:hover, .help-bubbles-container::-webkit-scrollbar-thumb:hover { background: #aaa; }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div class="w-full min-w-full overflow-x-auto px-4 py-8">
        <header class="mb-4 text-center relative">
            <img src="https://www.adifaltavelocidad.es/documents/34745/2553140/Logo_Adif_AV_verde_351x170.png/aa356add-9b30-836e-8d9f-276eb02d17cf?t=1617203111419&download=true" alt="Logo Adif" class="absolute top-0 left-0 h-24">
            <img src="https://www.ineco.com/ineco/sites/default/files/2022-12/Logo%20Ineco.png" alt="Logo Ineco" class="absolute top-0 right-0 h-16 mt-2">
            <h1 class="text-5xl font-bold text-[#005293] mb-2 hover:text-[#003d6f] transition-colors">MANTENIMIENTO LAV ESTE</h1>
            <h2 class="text-3xl font-semibold text-[#008080]">Preg√∫ntame</h2>
        </header>

        <div class="bg-white shadow-lg rounded-lg p-4 mb-6 border border-gray-300">
            <div class="flex flex-col sm:flex-row justify-center items-center gap-4">
                <div class="flex gap-2 sm:gap-4">
                    <button onclick="window.location.href='index.html'" class="px-3 py-2 sm:px-4 bg-[#008080] text-white rounded-md hover:bg-[#005293] transition-colors text-sm sm:text-base">üë®‚Äçüë©‚Äçüëß‚Äçüë¶ ORGANIGRAMA</button>
                    <button onclick="window.location.href='directorio.html'" class="px-3 py-2 sm:px-4 bg-[#008080] text-white rounded-md hover:bg-[#005293] transition-colors text-sm sm:text-base">üìû DIRECTORIO</button>
                    <button onclick="window.location.href='mapa.html'" class="px-3 py-2 sm:px-4 bg-[#008080] text-white rounded-md hover:bg-[#005293] transition-colors text-sm sm:text-base">üåç MAPA</button>
                </div>
            </div>
        </div>

        <div class="chat-container">
            <div class="chat-box" id="chatBox">
                <!-- Mensajes iniciales se a√±adir√°n aqu√≠ -->
            </div>
            <div id="helpBubblesContainer" class="help-bubbles-container flex flex-wrap gap-2 bg-gray-50 hidden"></div>
            <div class="input-area">
                <button id="helpButton" title="Ayuda" class="bg-blue-500 text-white rounded-full w-10 h-10 flex items-center justify-center hover:bg-blue-700 transition-colors text-lg mr-2">
                    <i class="fas fa-question"></i> <span class="button-text">Ayuda</span>
                </button>
                <button id="clearChatButton" title="Limpiar chat" class="bg-gray-500 text-white rounded-full w-10 h-10 flex items-center justify-center hover:bg-gray-700 transition-colors text-lg mr-2">
                    <i class="fas fa-eraser"></i> <span class="button-text">Limpiar Chat</span>
                </button>
                <input type="text" id="userInput" placeholder="Cargando..." autocomplete="off" disabled>
                <button id="sendButton" title="Enviar pregunta" disabled>
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        const chatBox = document.getElementById('chatBox');
        const userInput = document.getElementById('userInput');
        const sendButton = document.getElementById('sendButton');
        const helpBubblesContainer = document.getElementById('helpBubblesContainer');
        const clearChatButton = document.getElementById('clearChatButton');
        const helpButton = document.getElementById('helpButton');

        let unifiedData = [];
        let allPersons = [];
        let allLocations = [];
        let allPuestos = [];
        let entityIndex = new Map();
        const PENDING_NOM_LOWER = "pendiente de nombramiento";

        let conversationContext = {
            lastPerson: null,
            lastLocation: null,
            lastPuesto: null,
            clear: function() {
                this.lastPerson = null;
                this.lastLocation = null;
                this.lastPuesto = null;
            }
        };

        const USER_AVATAR_EMOJI = "üë§";
        const BOT_AVATAR_EMOJI = "ü§ñ";
        const INITIAL_BOT_MESSAGE = "¬°Hola! üëã Soy tu asistente virtual para el Mantenimiento LAV ESTE. Preg√∫ntame lo que necesites o escribe 'ayuda' para ver ejemplos.";

        let CONFIG_TYPO_CORRECTIONS = {};
        let CONFIG_INTENT_SYNONYMS = {};

        const SIMULATED_TYPOS_JSON = {
            "teleono": "telefono", "telefno": "telefono", "telf": "telefono", "tlf": "telefono",
            "nmero": "numero", "nummero": "numero", "telefonoo": "telefono", "tel√©fonoo": "telefono",
            "m√≥viles": "movil", "m√≥vil": "movil", "celulares": "celular", "celular": "movil",
            "extensi√≥n": "extension", "extensio": "extension", "ext": "extension",
            "ubicaion": "ubicacion", "ubicacoin": "ubicacion", "ubicaci√≥m": "ubicacion",
            "dondeesta": "donde esta", "dondeest√°": "donde esta", "donde": "donde",
            "localisacion": "localizacion", "localizaci√≥n": "localizacion", "localisaci√≥n": "localizacion",
            "uvicacion": "ubicacion", "ubiccacion": "ubicacion", "ubcacion": "ubicacion",
            "direcci√≥n": "direccion", "direccion": "direccion", "direncion": "direccion", "dierccion": "direccion",
            "emplazamiento": "ubicacion", "situacion": "ubicacion", "situaci√≥n": "ubicacion",
            "coreo": "correo", "corrreo": "correo", "emial": "email", "emeil": "email",
            "correo electronico": "correo", "correo-e": "correo", "e-mail": "email",
            "mail": "email", "correo@": "correo", "@": "", "arroba": "",
            "quien esla": "quien es la", "quienes": "quien es", "qien": "quien", "kienes": "quienes son", "kien": "quien",
            "el/la": "", "los/las": "", "un/una": "", "un": "", "una": "", "el": "", "la": "", "los": "", "las": "",
            "sr.": "", "sra.": "", "srta.": "", "d.": "", "da.": "", "d√±a.": "", "don": "", "do√±a": "",
            "tecnicos": "tecnico", "tecnicas": "tecnico", "tecnco": "tecnico", "t√©cnico": "tecnico", "t√©cnicos": "tecnico",
            "operadores": "operador", "operadoras": "operador", "operativa": "operativo", "operativos": "operativo",
            "jefes": "jefe", "gefe": "jefe", "gefa": "jefa", "jefas": "jefa", "jefesas": "jefa", "encargado": "jefe",
            "coordinador": "coordinacion", "coordinadores": "coordinacion", "coordinadora": "coordinacion",
            "responsable": "jefe", "responsables": "jefe", "director": "direccion", "directora": "direccion",
            "gerente": "gerencia", "subdirector": "subdireccion", "subdirectora": "subdireccion",
            "asistente": "asistencia", "asistentes": "asistencia", "ayudante": "asistente", "ayudantes": "asistente",
            "iiss": "ii.ss.", "is": "ii.ss.", "isss": "ii.ss.", "ii ss": "ii.ss.", "i.i.s.s.": "ii.ss.",
            "infra": "infraestructura", "infr": "infraestructura", "infraestructural": "infraestructura",
            "vias": "via", "v√≠a": "via", "v√≠as": "via", "linea": "linea", "l√≠nea": "linea", "lineas": "linea", "l√≠neas": "linea",
            "estacion": "estacion", "estaci√≥n": "estacion", "estaciones": "estacion",
            "tunel": "tunel", "t√∫nel": "tunel", "tuneles": "tunel", "t√∫neles": "tunel",
            "puente": "puente", "puentes": "puente", "viaducto": "puente", "viaductos": "puente",
            "bm ": "base de mantenimiento ", "b.m.": "base de mantenimiento", "bm": "base de mantenimiento", "base mtto": "base de mantenimiento",
            "crc ": "centro de regulacion y control ", "c.r.c.": "centro de regulacion y control", "crc": "centro de regulacion y control",
            "et ": "estacion de transformacion ", "e.t.": "estacion de transformacion", "et": "estacion de transformacion",
            "ctr ": "centro ", "ctr.": "centro", "ctr": "centro", "cntr": "centro", "cntro": "centro",
            "oficina": "oficina", "oficinas": "oficina", "despacho": "oficina", "despachos": "oficina",
            "almacen": "almacen", "almac√©n": "almacen", "almacenes": "almacen", "deposito": "almacen", "dep√≥sito": "almacen",
            "ambitos": "ambito", "ambto": "ambito", "amvito":"ambito", "√°mbito": "ambito", "ambitos": "ambito",
            "persoanl": "personal", "personla": "personal", "empleados": "personal", "trabajadores": "personal", "plantilla": "personal",
            "lisat": "lista", "listdo": "listado", "enumeracion": "lista", "enumeraci√≥n": "lista", "enumerar": "lista",
            "informaci√≥n": "informacion", "informacion": "informacion", "info": "informacion", "dato": "informacion", "datos": "informacion",
            "contacto": "contacto", "contactar": "contacto", "localizar": "contacto", "encontrar": "buscar", "busqueda": "buscar", "b√∫squeda": "buscar",
            "hola": "hola", "holi": "hola", "holis": "hola", "buenos dias": "hola", "buenos d√≠as": "hola",
            "buenas tardes": "hola", "buenas noches": "hola", "saludos": "hola", "saludo": "hola", "hey": "hola",
            "adios": "adios", "adi√≥s": "adios", "hasta luego": "adios", "hasta pronto": "adios", "nos vemos": "adios", "chao": "adios", "bye": "adios",
            "gracias": "gracias", "gracia": "gracias", "grasias": "gracias", "muchas gracias": "gracias", "mil gracias": "gracias",
            "por favor": "por favor", "porfavor": "por favor", "porfa": "por favor", "porfi": "por favor", "haz el favor": "por favor",
            "ok": "ok", "okey": "ok", "okey": "ok", "okis": "ok", "vale": "ok", "va": "ok", "listo": "ok", "de acuerdo": "ok", "esta bien": "ok",
            "si": "si", "s√≠": "si", "sip": "si", "afirmativo": "si", "claro": "si", "por supuesto": "si", "desde luego": "si",
            "no": "no", "nop": "no", "nones": "no", "para nada": "no", "ni hablar": "no", "de ninguna manera": "no", "jam√°s": "no", "nunca": "no",
            "ayuda": "ayuda", "soporte": "ayuda", "asistencia": "ayuda", "auxilio": "ayuda", "socorro": "ayuda",
            "ivan de la paz": "ivan de la paz notario",
            "javier gambin": "javier gambin ortu√±o",
            "juan jose recio": "juan jose recio lanchas",
            "silvia garcia": "silvia garcia maroto",
            "manuel garcia": "manuel garcia diaz",
            "jesus fernandez": "jesus fernandez aviles",
            "telemando": "operador tme",
            "operador telemando": "operador tme",
            "tme": "operador tme",
            "operador tme": "operador tme",
            "operador de telemando": "operador tme",
            "operadora tme": "operador tme",
            "operadora de telemando": "operador tme",
            "operador de tele mando": "operador tme",
            "operador tele mando": "operador tme"
        };

        const SIMULATED_SYNONYMS_JSON = {
            telefono: ["tel√©fono", "telefono", "contacto telefonico", "llamar", "numero de telefono", "m√≥vil", "movil", "phone", "celular", "fono", "num"],
            correo: ["correo", "email", "e-mail", "direccion de correo", "direcci√≥n de correo", "contactar por email", "mail"],
            puesto: ["puesto", "cargo", "rol", "funcion", "funci√≥n", "ocupacion", "ocupaci√≥n", "que hace", "qu√© hace", "a que se dedica", "a qu√© se dedica", "trabajo de", "labor", "responsabilidad de", "cometido", "posicion", "posici√≥n"],
            ubicacion: ["ubicaci√≥n", "ubicacion", "centro", "lugar", "donde esta", "d√≥nde est√°", "donde trabaja", "d√≥nde trabaja", "localizacion", "localizaci√≥n", "sede", "emplazamiento", "sitio", "localidad", "base", "estacion"],
            quien_es: ["qui√©n es", "quien es", "info de", "informacion sobre", "dame datos de", "datos sobre", "cuentame de", "cu√©ntame de", "detalles de", "saber de", "quien se encarga de", "informacion de", "info sobre"],
            personas_en_loc: ["personas", "personal", "equipo", "gente", "trabajadores", "quienes trabajan", "qui√©nes trabajan", "cuantos hay", "cu√°ntos hay", "listado de personal", "plantilla", "nomina de", "quien esta en", "qui√©n est√° en", "empleados en", "miembros en", "trabaja en", "cuanta gente hay en"],
            ambito: ["√°mbito", "ambito", "mantenimiento de", "cubre", "alcance", "responsable de linea", "l√≠neas que cubre", "lineas que cubre", "tramo", "se encarga de", "competencia de", "area de mantenimiento", "√°rea de mantenimiento"],
            direccion_loc: ["direcci√≥n", "direccion", "como llego", "c√≥mo llego", "como ir", "c√≥mo ir", "ubicacion fisica", "ubicaci√≥n f√≠sica", "donde se encuentra", "d√≥nde se encuentra", "mapa de", "localizar", "ir a"],
            lista: ["lista de", "listado de", "dime los", "dime todos", "cuales son", "cu√°les son", "muestrame", "mu√©strame", "todos los", "todas las", "listar", "enumerar", "dame una lista", "ver todos"],
            saludo: ["hola", "buenos dias", "buenos d√≠as", "buenas tardes", "buenas noches", "hey", "que tal", "qu√© tal", "buenas", "saludos", "que pasa", "qu√© pasa", "epa"],
            despedida: ["adios", "adi√≥s", "hasta luego", "chao", "nos vemos", "bye", "hasta pronto", "finalizar", "terminar", "me voy"],
            agradecimiento: ["gracias", "muchas gracias", "agradecido", "muy amable", "ok gracias", "vale gracias", "perfecto gracias", "genial gracias", "te lo agradezco", "excelente", "gracias!"],
            ayuda_cmd: ["ayuda", "comandos", "que puedes hacer", "qu√© puedes hacer", "opciones", "info", "informacion", "help", "manual", "instrucciones", "como funciona", "c√≥mo funciona"],
            y_su: ["y su", "y el de el", "y la de el", "y el de ella", "y la de ella", "tambien su", "tambi√©n su", "dime tambien", "dime tambi√©n", "necesito tambien", "necesito tambi√©n", "adem√°s su", "ademas su", "y el suyo", "y la suya", "dame tambi√©n su"],
            solo_eso: ["solo eso", "nada mas", "nada m√°s", "eso es todo", "listo", "ok", "vale", "ya esta", "ya est√°", "perfecto"],
            comparar_mas: ["mas", "m√°s", "mayor numero", "mayor n√∫mero", "quien tiene mas", "qui√©n tiene m√°s", "donde hay mas", "d√≥nde hay m√°s", "cual tiene mas", "cu√°l tiene m√°s", "que tiene mas", "qu√© tiene m√°s"],
            comparar_o: [" o ", " √≥ ", " versus ", " vs "]
        };

        const typingIndicatorElement = document.createElement('div');
        typingIndicatorElement.classList.add('typing-indicator');
        typingIndicatorElement.innerHTML = '<span></span><span></span><span></span>';
        let isTyping = false;
        let dataLoaded = false;

        async function loadExternalConfigs() {
            CONFIG_TYPO_CORRECTIONS = SIMULATED_TYPOS_JSON;
            CONFIG_INTENT_SYNONYMS = SIMULATED_SYNONYMS_JSON;
        }

        async function loadData() {
            appendMessage('bot', 'Cargando datos y configuraciones, por favor espera...');
            try {
                await loadExternalConfigs();
                const response = await fetch('./unified_data.json');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status} al cargar unified_data.json`);
                unifiedData = await response.json();

                allPersons = [];
                allLocations = [];
                const puestosSet = new Set();

                unifiedData.forEach(centro => {
                    allLocations.push({ ...centro, personas: undefined });
                    if (centro.personas) {
                        centro.personas.forEach(persona => {
                            allPersons.push({ ...persona, ubicacion: centro.nombre_centro });
                            if (persona.puesto && persona.puesto.toLowerCase() !== PENDING_NOM_LOWER) {
                                puestosSet.add(persona.puesto);
                            }
                        });
                    }
                });
                allPuestos = Array.from(puestosSet).sort();

                buildEntityIndex();
                dataLoaded = true;
                chatBox.innerHTML = '';
                appendMessage('bot', INITIAL_BOT_MESSAGE);
                userInput.disabled = false;
                sendButton.disabled = false;
                userInput.placeholder = "Escribe tu pregunta aqu√≠...";
                userInput.focus();

            } catch (error) {
                console.error("Error cr√≠tico durante la carga:", error);
                appendMessage('bot', `Error cr√≠tico al cargar: ${error.message}. Por favor, revisa la consola.`);
                userInput.placeholder = "Error al cargar datos.";
            }
        }

        function normalize(text, preserveSpecialChars = false) {
            if (!text || typeof text !== 'string') return '';
            let normalized = text.toLowerCase().trim();
            normalized = normalized.normalize("NFD").replace(/[\u0300-\u036f]/g, "");

            for (const typo in CONFIG_TYPO_CORRECTIONS) {
                const correction = CONFIG_TYPO_CORRECTIONS[typo];
                const escapedTypo = typo.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(`(^|\\s)${escapedTypo}(\\s|$)`, 'gi');
                normalized = normalized.replace(regex, `$1${correction}$2`);
                if (normalized === typo) {
                    normalized = correction;
                } else if (normalized.startsWith(typo + ' ')) {
                    normalized = normalized.replace(typo, correction);
                } else if (normalized.endsWith(' ' + typo)) {
                    normalized = normalized.replace(typo, correction);
                }
            }
            normalized = normalized.replace(/\b(\d{3})[-\.\s]?(\d{2})[-\.\s]?(\d{2})[-\.\s]?(\d{2})\b/g, '$1$2$3$4');
            normalized = normalized.replace(/\bext\.?\s*\b(\d+)\b/gi, 'extension $1');
            normalized = normalized.replace(/\s+/g, ' ').trim();
            if (!preserveSpecialChars) {
                normalized = normalized.replace(/[^a-z0-9\s]/gi, '');
            }
            return normalized;
        }

        function buildEntityIndex() {
            entityIndex.clear();
            const addEntity = (key, data, type, originalKey, relevanceScore = 1.0) => {
                const normalizedKey = normalize(key, type.startsWith('puesto_') || type.startsWith('person_') || type.startsWith('location_'));
                if (!normalizedKey) return;

                if (!entityIndex.has(normalizedKey)) {
                    entityIndex.set(normalizedKey, []);
                }
                if (!entityIndex.get(normalizedKey).some(e => e.type === type && JSON.stringify(e.data) === JSON.stringify(data))) {
                     entityIndex.get(normalizedKey).push({ data, type, originalKey: originalKey || key, relevance: relevanceScore });
                }
            };

            allPersons.forEach(person => {
                if (person.nombre && person.nombre.toLowerCase() !== PENDING_NOM_LOWER) {
                    addEntity(person.nombre, person, 'person_full', person.nombre, 1.0);
                    const nameParts = person.nombre.split(' ');
                    if (nameParts.length > 1) {
                        addEntity(nameParts[0], person, 'person_firstname', person.nombre, 0.5);
                        const lastNamesString = nameParts.slice(1).join(' ');
                        if (lastNamesString) {
                            addEntity(lastNamesString, person, 'person_all_lastnames', person.nombre, 0.7);
                        }
                        if (nameParts.length >= 2) {
                             addEntity(`${nameParts[0]} ${nameParts[1]}`, person, 'person_name_firstlastname', person.nombre, 0.9);
                        }
                        if (nameParts.length >= 2) {
                            let firstLastName = nameParts[1];
                            let isCompoundLastNameStart = false;
                            const compoundConnectors = ['de', 'del', 'la', 'los', 'las'];
                            if (compoundConnectors.includes(firstLastName.toLowerCase()) && nameParts.length > 2) {
                                firstLastName = nameParts[2];
                                addEntity(`${nameParts[1]} ${nameParts[2]}`, person, 'person_first_compound_lastname_part', person.nombre, 0.72);
                                isCompoundLastNameStart = true;
                            }
                            addEntity(firstLastName, person, 'person_first_lastname_alone', person.nombre, 0.65);
                            if(isCompoundLastNameStart && nameParts.length > 2) {
                                addEntity(`${nameParts[0]} ${nameParts[1]} ${nameParts[2]}`, person, 'person_name_first_compound_lastname', person.nombre, 0.92);
                            }
                        }
                        if (nameParts.length >= 3) {
                             addEntity(`${nameParts[0]} ${nameParts[1]} ${nameParts[2]}`, person, 'person_name_two_lastnames', person.nombre, 0.95);
                        }
                         if (nameParts.length > 2 && nameParts[nameParts.length -1]) {
                            addEntity(nameParts[nameParts.length -1], person, 'person_last_lastname_alone', person.nombre, 0.6);
                        }
                    }
                }
                 if (person.puesto && person.puesto.toLowerCase() !== PENDING_NOM_LOWER) {
                    addEntity(person.puesto, {nombre_puesto: person.puesto, original_persona_puesto: person.puesto}, 'puesto_general', person.puesto, 0.9);
                    if (person.puesto.toLowerCase().includes("jefe de base")) addEntity("jefe de base", {nombre_puesto: "Jefe de Base", original_persona_puesto: person.puesto}, 'puesto_variant', person.puesto, 0.8);
                    if (person.puesto.toLowerCase().includes("tecnico de infra y via")) addEntity("tecnico de via", {nombre_puesto: "T√©cnico De Infra y V√≠a", original_persona_puesto: person.puesto}, 'puesto_variant', person.puesto, 0.8);
                    if (person.puesto.toLowerCase().includes("c.t. ingenieria civil")) addEntity("ct ingenieria civil", {nombre_puesto: "C.T. Ingenier√≠a Civil", original_persona_puesto: person.puesto}, 'puesto_variant', person.puesto, 0.8);
                    if (person.puesto.toLowerCase().startsWith("tecnico ")) addEntity("tecnico", {nombre_puesto: "T√©cnico", original_persona_puesto: person.puesto}, 'puesto_generic_term', person.puesto, 0.5);
                    if (person.puesto.toLowerCase().startsWith("operador ")) addEntity("operador", {nombre_puesto: "Operador", original_persona_puesto: person.puesto}, 'puesto_generic_term', person.puesto, 0.5);
                    if (person.puesto.toLowerCase() === "operador tme") addEntity("telemando", {nombre_puesto: "Operador TME", original_persona_puesto: person.puesto}, 'puesto_alias', person.puesto, 0.85);
                    if (person.puesto.toLowerCase() === "operador csi") addEntity("csi", {nombre_puesto: "Operador CSI", original_persona_puesto: person.puesto}, 'puesto_alias', person.puesto, 0.85);


                }
                if (person.telefono && person.telefono !== PENDING_NOM_LOWER) {
                    const phoneDigits = person.telefono.replace(/\D/g, '');
                    addEntity(phoneDigits, person, 'person_phone', person.nombre, 0.99);
                    addEntity(person.telefono, person, 'person_phone_formatted', person.nombre, 0.98);
                }
            });

            allLocations.forEach(location => {
                addEntity(location.nombre_centro, location, 'location_full', location.nombre_centro, 1.0);
                if (location.nombre_centro.toLowerCase().startsWith("bm ")) addEntity(location.nombre_centro.substring(3), location, 'location_shortname', location.nombre_centro, 0.8);
                if (location.nombre_centro.toLowerCase().startsWith("et ")) addEntity(location.nombre_centro.substring(3), location, 'location_shortname', location.nombre_centro, 0.8);
                if (location.nombre_centro.toLowerCase().startsWith("crc ")) addEntity(location.nombre_centro.substring(4), location, 'location_shortname', location.nombre_centro, 0.8);

                const keywords = location.nombre_centro.split(/[\s-]+/).filter(kw => kw.length > 2 && !["de", "la", "el", "los", "las", "paseo"].includes(kw.toLowerCase()));
                keywords.forEach(kw => addEntity(kw, location, 'location_keyword', location.nombre_centro, 0.6));
            });

            addEntity(PENDING_NOM_LOWER, { nombre: PENDING_NOM_LOWER, puesto: PENDING_NOM_LOWER }, 'person_pending', PENDING_NOM_LOWER, 0.9);

            const explicitPuestos = ["jefe de area", "jefe de base", "coordinador de linea", "secretaria", "tecnico ii.ss.", "tecnico iiss", "tecnico de infra y via", "tecnico infra via", "tecnico energia", "tecnico de energia", "tecnico telecomunicaciones", "ct ingenieria civil", "ct ingenier√≠a civil", "tecnico", "operador", "gtm", "operador csi", "operador tme", "jefe de unidad", "tecnico documentalista", "tecnico de inversiones", "tecnico proyectos y explanaciones", "tecnico de proteccion civil", "tecnico analisis incidencias"];
            explicitPuestos.forEach(puesto => {
                 addEntity(puesto, { nombre_puesto: puesto }, 'puesto_explicit', puesto, 0.95);
            });
        }

        const COMMON_WORDS = new Set(['de', 'del', 'la', 'el', 'los', 'las', 'y', 'e', 'o', 'u', 'a', 'en', 'con', 'por', 'para', 'al', 'se', 'su', 'sus', 'un', 'una', 'unos', 'unas']);

        function findEntities(normalizedInput) {
            let foundEntities = [];
            const inputWords = normalizedInput
                .split(' ')
                .filter(w => w.length > 0 && !COMMON_WORDS.has(w.toLowerCase()));

            for (let len = Math.min(inputWords.length, 7); len >= 1; len--) {
                for (let i = 0; i <= inputWords.length - len; i++) {
                    const phrase = inputWords.slice(i, i + len).join(' ');
                    const normalizedPhrase = normalize(phrase, true);
                    if (!normalizedPhrase) continue;

                    if (entityIndex.has(normalizedPhrase)) {
                        entityIndex.get(normalizedPhrase).forEach(entity => {
                            const existingIndex = foundEntities.findIndex(fe => JSON.stringify(fe.data) === JSON.stringify(entity.data) && fe.type === entity.type);
                            if (existingIndex !== -1) {
                                if (len > foundEntities[existingIndex].length ||
                                   (len === foundEntities[existingIndex].length && entity.type.includes('_full') && !foundEntities[existingIndex].type.includes('_full')) ||
                                   (len === foundEntities[existingIndex].length && (entity.relevance || 0) > (foundEntities[existingIndex].relevance || 0) ) ||
                                   (len === foundEntities[existingIndex].length && entity.type === 'person_phone' && foundEntities[existingIndex].type !== 'person_phone')
                                ) {
                                    foundEntities.splice(existingIndex, 1, { ...entity, matchedKey: normalizedPhrase, matchType: 'exact_phrase', length: len });
                                }
                            } else {
                                 foundEntities.push({ ...entity, matchedKey: normalizedPhrase, matchType: 'exact_phrase', length: len });
                            }
                        });
                    }
                }
            }

            if (normalizedInput.includes(PENDING_NOM_LOWER)) {
                 const pteEntityArray = entityIndex.get(PENDING_NOM_LOWER);
                if (pteEntityArray && pteEntityArray.length > 0) {
                    const pteEntity = pteEntityArray[0];
                     if (!foundEntities.some(fe => fe.type === 'person_pending')) {
                        foundEntities.push({ ...pteEntity, matchedKey: PENDING_NOM_LOWER, matchType: 'exact_phrase', length: PENDING_NOM_LOWER.split(' ').length });
                    }
                }
            }

            foundEntities.sort((a, b) => {
                 const typePriority = (type) => {
                    if (type === 'person_phone') return -2;
                    if (type === 'person_phone_formatted') return -1;
                    if (type === 'person_full') return 0;
                    if (type.startsWith('location_full')) return 0;
                    if (type === 'person_name_two_lastnames') return 1;
                    if (type === 'person_name_first_compound_lastname') return 1;
                    if (type.startsWith('puesto_explicit') || type.startsWith('puesto_general') || type.startsWith('puesto_alias')) return 1;
                    if (type === 'person_name_firstlastname') return 2;
                    if (type === 'person_all_lastnames') return 3;
                    if (type === 'person_first_lastname_alone') return 4;
                    if (type === 'person_last_lastname_alone') return 4;
                    if (type === 'person_firstname') return 5;
                    return 6;
                };

                if (typePriority(a.type) !== typePriority(b.type)) {
                    return typePriority(a.type) - typePriority(b.type);
                }
                if (a.length !== b.length) return b.length - a.length;
                if (Math.abs((b.relevance || 0) - (a.relevance || 0)) > 0.01) {
                    return (b.relevance || 0) - (a.relevance || 0);
                }
                return (b.relevance || 0) - (a.relevance || 0);
            });

            const finalFiltered = [];
            const finalSeenData = new Set();
            for(const entity of foundEntities){
                const dataKey = JSON.stringify(entity.data);
                if(!finalSeenData.has(dataKey)){
                    finalFiltered.push(entity);
                    finalSeenData.add(dataKey);
                }
            }
            return finalFiltered;
        }

        function checkKeywords(normalizedInput, intentKey, exact = false) {
            if (!CONFIG_INTENT_SYNONYMS[intentKey]) return false;
            const keywords = CONFIG_INTENT_SYNONYMS[intentKey];
            const normalizedInputForCheck = normalize(normalizedInput);

            if (exact) {
                return keywords.some(kw => normalize(kw) === normalizedInputForCheck);
            }
            return keywords.some(kw => normalizedInputForCheck.includes(normalize(kw)));
        }

        let intentionRules = [];

        function defineIntentionRules() {
            intentionRules = [
                {
                    name: "find_person_by_phone",
                    condition: (ni, ent, ctx, originalInput) => {
                        const phoneQuery = (originalInput || ni).replace(/\s+/g, '');
                        return /^\+?\d{9,15}$/.test(phoneQuery) && ent.some(e => e.type === 'person_phone' && e.data.telefono.replace(/\D/g,'') === phoneQuery.replace(/\D/g,''));
                    },
                    action: (ni, ent, ctx, originalInput) => {
                        const phoneQuery = (originalInput || ni).replace(/\D/g, '');
                        const personEntity = ent.find(e => e.type === 'person_phone' && e.data.telefono.replace(/\D/g,'') === phoneQuery);
                        if (personEntity) {
                            conversationContext.lastPerson = personEntity.data;
                            conversationContext.lastLocation = null; conversationContext.lastPuesto = null;
                            return `El n√∫mero de tel√©fono **${personEntity.data.telefono}** pertenece a ${formatPersonInfo(personEntity.data)}`;
                        }
                        return "No encontr√© a nadie con ese n√∫mero de tel√©fono.";
                    }
                },
                {
                    name: "context_person_telefono",
                    condition: (ni, ent, ctx) => ctx.lastPerson && checkKeywords(ni, 'y_su') && checkKeywords(ni, 'telefono'),
                    action: (ni, ent, ctx) => { conversationContext.lastLocation = null; conversationContext.lastPuesto = null; return formatPersonInfo(ctx.lastPerson, 'telefono');}
                },
                {
                    name: "context_person_correo",
                    condition: (ni, ent, ctx) => ctx.lastPerson && checkKeywords(ni, 'y_su') && checkKeywords(ni, 'correo'),
                    action: (ni, ent, ctx) => { conversationContext.lastLocation = null; conversationContext.lastPuesto = null; return formatPersonInfo(ctx.lastPerson, 'correo');}
                },
                {
                    name: "context_person_puesto",
                    condition: (ni, ent, ctx) => ctx.lastPerson && checkKeywords(ni, 'y_su') && checkKeywords(ni, 'puesto'),
                    action: (ni, ent, ctx) => { conversationContext.lastLocation = null; conversationContext.lastPuesto = null; return formatPersonInfo(ctx.lastPerson, 'puesto');}
                },
                {
                    name: "context_person_ubicacion",
                    condition: (ni, ent, ctx) => ctx.lastPerson && checkKeywords(ni, 'y_su') && checkKeywords(ni, 'ubicacion'),
                    action: (ni, ent, ctx) => { conversationContext.lastLocation = null; conversationContext.lastPuesto = null; return formatPersonInfo(ctx.lastPerson, 'ubicacion');}
                },
                {
                    name: "context_location_ambitos",
                    condition: (ni, ent, ctx) => ctx.lastLocation && checkKeywords(ni, 'y_su') && checkKeywords(ni, 'ambito'),
                    action: (ni, ent, ctx) => { conversationContext.lastPerson = null; conversationContext.lastPuesto = null; return formatLocationInfo(ctx.lastLocation, 'ambitos');}
                },
                {
                    name: "context_location_persons",
                    condition: (ni, ent, ctx) => ctx.lastLocation && checkKeywords(ni, 'y_su') && checkKeywords(ni, 'personas_en_loc'),
                    action: (ni, ent, ctx) => { conversationContext.lastPerson = null; conversationContext.lastPuesto = null; return formatLocationInfo(ctx.lastLocation, 'personas');}
                },
                {
                    name: "context_location_details",
                    condition: (ni, ent, ctx) => ctx.lastLocation && checkKeywords(ni, 'y_su') && checkKeywords(ni, 'direccion_loc'),
                    action: (ni, ent, ctx) => { conversationContext.lastPerson = null; conversationContext.lastPuesto = null; return formatLocationInfo(ctx.lastLocation, 'direccion');}
                },
                {
                    name: "context_puesto_persons",
                    condition: (ni, ent, ctx) => ctx.lastPuesto && checkKeywords(ni, 'y_su') && checkKeywords(ni, 'personas_en_loc'),
                    action: (ni, ent, ctx) => {
                        conversationContext.lastPerson = null; conversationContext.lastLocation = null;
                        const pEntities = findEntities(normalize(ctx.lastPuesto.nombre_puesto, true));
                        return getIntentResponse(ni, pEntities, 'find_person_by_role');
                    }
                },
                {
                    name: "context_acknowledged",
                    condition: (ni, ent, ctx) => (ctx.lastPerson || ctx.lastLocation || ctx.lastPuesto) && checkKeywords(ni, 'solo_eso', true),
                    action: (ni, ent, ctx) => { conversationContext.clear(); return "Entendido."; }
                },
                {
                    name: "ayuda",
                    condition: (ni) => checkKeywords(ni, 'ayuda_cmd', true) || ni === 'ayuda',
                    action: () => { displayHelpBubbles(); return 'Puedo ayudarte con informaci√≥n sobre personal, centros y listados. Aqu√≠ tienes ejemplos:'; }
                },
                { name: "saludo", condition: (ni) => checkKeywords(ni, 'saludo'), action: () => CONFIG_INTENT_SYNONYMS.saludo[Math.floor(Math.random() * CONFIG_INTENT_SYNONYMS.saludo.length)] + "! ¬øEn qu√© puedo ayudarte?" },
                { name: "despedida", condition: (ni) => checkKeywords(ni, 'despedida'), action: () => CONFIG_INTENT_SYNONYMS.despedida[Math.floor(Math.random() * CONFIG_INTENT_SYNONYMS.despedida.length)] + "! Que tengas un buen d√≠a." },
                { name: "agradecimiento", condition: (ni) => checkKeywords(ni, 'agradecimiento'), action: () => "De nada. ¬°Ha sido un placer ayudarte!" },
                {
                    name: "find_specific_person_by_role_and_location",
                    condition: (ni, ent, ctx, originalInputString) => {
                        const puestos = ent.filter(e => e.type.startsWith('puesto_') || e.type.startsWith('puesto_alias'));
                        const locations = ent.filter(e => e.type.startsWith('location_'));

                        if (puestos.length === 0 || locations.length === 0) return false;
                        
                        let bestPuestoEntity = null;
                        let bestLocationEntity = null;

                        puestos.sort((a,b) => (b.data.nombre_puesto || b.originalKey || "").length - (a.data.nombre_puesto || a.originalKey || "").length);
                        for (const p of puestos) {
                            const pNameNorm = normalize(p.data.nombre_puesto || p.originalKey, true);
                            if (pNameNorm && ni.includes(pNameNorm)) {
                                bestPuestoEntity = p;
                                break;
                            }
                        }
                        locations.sort((a,b) => (b.data.nombre_centro || "").length - (a.data.nombre_centro || "").length);
                        for (const l of locations) {
                            const lNameNorm = normalize(l.data.nombre_centro, true);
                            if (lNameNorm && ni.includes(lNameNorm)) {
                                bestLocationEntity = l;
                                break;
                            }
                        }
                        
                        if (!bestPuestoEntity || !bestLocationEntity) return false;

                        const puestoNameNorm = normalize(bestPuestoEntity.data.nombre_puesto || bestPuestoEntity.originalKey, true);
                        const locationNameNorm = normalize(bestLocationEntity.data.nombre_centro, true);
                        
                        const hasQuestionKeyword = checkKeywords(ni, 'quien_es') || ni.startsWith("dime los") || ni.startsWith("cuales son los");
                        const patternPuestoEnUbicacion = new RegExp(`${puestoNameNorm}\\s+(en|de)\\s+${locationNameNorm}`, 'i');
                        const patternQuienEsPuestoEnUbicacion = new RegExp(`(qui[e√©]n(es)?|dime|cuales son)\\s+(el|la|los|las)?\\s*${puestoNameNorm}\\s+(en|de)\\s+${locationNameNorm}`, 'i');
                        const combinedLength = puestoNameNorm.length + locationNameNorm.length;
                        const queryCoveredRatio = ni.length > 0 ? combinedLength / ni.length : 0;


                        if ( (ni.match(patternPuestoEnUbicacion) || ni.match(patternQuienEsPuestoEnUbicacion)) && queryCoveredRatio > 0.65 ) {
                            const personsInEnt = ent.filter(e => e.type.startsWith('person_'));
                            if (personsInEnt.some(p => ni.includes(normalize(p.data.nombre, true)) && p.length > puestoNameNorm.length && p.length > locationNameNorm.length)) {
                                return false;
                            }
                            return true;
                        }
                        return false;
                    },
                    action: (ni, ent, ctx, originalInputString) => {
                        let bestPuestoEntity = null;
                        let bestLocationEntity = null;
                        const puestos = ent.filter(e => e.type.startsWith('puesto_') || e.type.startsWith('puesto_alias'));
                        const locations = ent.filter(e => e.type.startsWith('location_'));

                        puestos.sort((a,b) => (b.data.nombre_puesto || b.originalKey || "").length - (a.data.nombre_puesto || a.originalKey || "").length);
                        for (const p of puestos) {
                            const pNameNorm = normalize(p.data.nombre_puesto || p.originalKey, true);
                            if (pNameNorm && ni.includes(pNameNorm)) { bestPuestoEntity = p; break; }
                        }
                        locations.sort((a,b) => (b.data.nombre_centro || "").length - (a.data.nombre_centro || "").length);
                        for (const l of locations) {
                            const lNameNorm = normalize(l.data.nombre_centro, true);
                            if (lNameNorm && ni.includes(lNameNorm)) { bestLocationEntity = l; break; }
                        }

                        if (!bestPuestoEntity || !bestLocationEntity) {
                            return "Error al procesar la solicitud de puesto y ubicaci√≥n espec√≠fica.";
                        }

                        const targetPuestoNorm = normalize(bestPuestoEntity.data.nombre_puesto || bestPuestoEntity.originalKey, true);
                        const targetLocationName = bestLocationEntity.data.nombre_centro;
                        const displayPuesto = bestPuestoEntity.data.nombre_puesto || bestPuestoEntity.originalKey;

                        const peopleFound = allPersons.filter(p =>
                            p.puesto && normalize(p.puesto, true).includes(targetPuestoNorm) &&
                            p.ubicacion === targetLocationName &&
                            p.nombre.toLowerCase() !== PENDING_NOM_LOWER
                        );

                        if (peopleFound.length === 1) {
                            conversationContext.lastPerson = peopleFound[0];
                            conversationContext.lastLocation = bestLocationEntity.data;
                            conversationContext.lastPuesto = bestPuestoEntity.data;
                            return `El/La **${displayPuesto}** en **${targetLocationName}** es ${formatPersonInfo(peopleFound[0])}`;
                        } else if (peopleFound.length > 1) {
                            conversationContext.lastLocation = bestLocationEntity.data;
                            conversationContext.lastPuesto = bestPuestoEntity.data;
                            const list = peopleFound.map(p => `- **${p.nombre}**`).join('\n');
                            return `Encontr√© las siguientes personas como **${displayPuesto}** en **${targetLocationName}**:\n${list}`;
                        } else {
                            const puestoExistsAnywhere = allPersons.some(p => p.puesto && normalize(p.puesto, true).includes(targetPuestoNorm) && p.nombre.toLowerCase() !== PENDING_NOM_LOWER);
                            if(puestoExistsAnywhere) {
                                return `No encontr√© a nadie con el puesto de **${displayPuesto}** espec√≠ficamente en **${targetLocationName}**. ¬øQuiz√°s en otra ubicaci√≥n?`;
                            }
                            return `No encontr√© a nadie con el puesto de **${displayPuesto}** en **${targetLocationName}**, o el puesto est√° pendiente de nombramiento all√≠.`;
                        }
                    }
                },
                {
                    name: "find_person_by_role_direct",
                    condition: (ni, ent, ctx, originalInputString) => {
                        const puestos = ent.filter(e => e.type.startsWith('puesto_') || e.type.startsWith('puesto_alias'));
                        if (puestos.length === 0) return false;

                        const mainPuestoEntity = puestos.sort((a, b) => (b.data.nombre_puesto || b.originalKey || "").length - (a.data.nombre_puesto || a.originalKey || "").length)[0];
                        const mainPuestoName = normalize(mainPuestoEntity.data.nombre_puesto || mainPuestoEntity.originalKey, true);

                        if (mainPuestoName && ni === mainPuestoName && 
                            ent.filter(e => e.type.startsWith('person_')).length === 0 && 
                            ent.filter(e => e.type.startsWith('location_')).length === 0) {
                            return true;
                        }

                        if ((checkKeywords(ni, 'lista') || checkKeywords(ni, 'quien_es')) && 
                            puestos.some(p => {
                                const pName = normalize(p.data.nombre_puesto || p.originalKey, true);
                                return pName && ni.includes(pName);
                            }) &&
                            ent.filter(e => e.type.startsWith('location_')).length === 0 
                            ) {
                            if (checkKeywords(ni, 'quien_es')) {
                                let namePart = ni;
                                (CONFIG_INTENT_SYNONYMS.quien_es || []).forEach(syn => namePart = namePart.replace(normalize(syn), ''));
                                (puestos.map(p => normalize(p.data.nombre_puesto || p.originalKey, true))).filter(Boolean).forEach(pn => namePart = namePart.replace(pn, ''));
                                namePart = namePart.trim();
                                if (namePart && ent.some(e => e.type.startsWith('person_') && normalize(e.data.nombre, true).includes(namePart))) {
                                    return false;
                                }
                            }
                            return true;
                        }
                        
                        const wordsInQuery = ni.split(' ').length;
                        if (mainPuestoName && wordsInQuery <= 3 && mainPuestoEntity && ni.includes(mainPuestoName) &&
                            ent.filter(e => e.type.startsWith('person_')).length === 0 &&
                            ent.filter(e => e.type.startsWith('location_')).length === 0) {
                            if (ni === mainPuestoName) return true;
                        }
                        return false;
                    },
                    action: (ni, ent, ctx, originalInput) => {
                        const puestoData = ent.filter(e => e.type.startsWith('puesto_') || e.type.startsWith('puesto_alias')).sort((a,b) => (b.data.nombre_puesto || b.originalKey || "").length - (a.data.nombre_puesto || a.originalKey || "").length)[0];
                        return getIntentResponse(ni, ent, 'find_person_by_role', originalInput);
                    }
                },
                {
                    name: "get_person_specific_info_or_full",
                    condition: (ni, ent, ctx, originalInput) => {
                        const persons = ent.filter(e => e.type.startsWith('person_') && e.type !== 'person_pending');
                        if (persons.length !== 1) return false;

                        const personEntity = persons[0];
                        const personData = personEntity.data;

                        const specificInfoKeywordsData = [
                            { key: 'telefono', synonyms: CONFIG_INTENT_SYNONYMS.telefono || [] },
                            { key: 'correo', synonyms: CONFIG_INTENT_SYNONYMS.correo || [] },
                            { key: 'puesto', synonyms: CONFIG_INTENT_SYNONYMS.puesto || [] },
                            { key: 'ubicacion', synonyms: CONFIG_INTENT_SYNONYMS.ubicacion || [] }
                        ];

                        let requestedSpecificInfo = null;
                        let nameQueryPart = ni;

                        for (const infoData of specificInfoKeywordsData) {
                            for (const syn of infoData.synonyms) {
                                const normSyn = normalize(syn);
                                const regex = new RegExp(`(^|\\s)${normSyn}(\\sde|\\sdel|\\s)?`, 'i');
                                const match = ni.match(regex);
                                if (match) {
                                    requestedSpecificInfo = infoData.key;
                                    nameQueryPart = ni.substring(match.index + match[0].length).trim();
                                    nameQueryPart = nameQueryPart.replace(/^(el|la|los|las)\s/i, '').trim();
                                    break;
                                }
                            }
                            if (requestedSpecificInfo) break;
                        }

                        if (requestedSpecificInfo) {
                            const normMatchedKey = normalize(personEntity.matchedKey, true);
                            const normNameQueryPart = normalize(nameQueryPart, true);

                            if (normNameQueryPart && (normMatchedKey === normNameQueryPart || normMatchedKey.includes(normNameQueryPart) || normNameQueryPart.includes(normMatchedKey))) {
                                if (normNameQueryPart.split(' ').length >= 1 && personEntity.length >= Math.max(1, normNameQueryPart.split(' ').length -1 )) {
                                     if (! (personEntity.type === 'person_firstname' && normNameQueryPart.split(' ').length > 1) ) {
                                        return true;
                                     }
                                }
                            }
                        } else {
                            if (checkKeywords(ni, 'quien_es')) {
                                let tempNameQueryPart = ni;
                                (CONFIG_INTENT_SYNONYMS.quien_es || []).forEach(syn => {
                                    const normSyn = normalize(syn);
                                    if (tempNameQueryPart.startsWith(normSyn)) {
                                        tempNameQueryPart = tempNameQueryPart.substring(normSyn.length).trim();
                                    }
                                });
                                tempNameQueryPart = tempNameQueryPart.replace(/^(el|la|los|las)\s/i, '').trim();
                                 if (normalize(personEntity.matchedKey, true) === normalize(tempNameQueryPart, true) && tempNameQueryPart) return true;
                            }
                            if (ni === personEntity.matchedKey && personEntity.length >= Math.max(1, ni.split(' ').length -1)) {
                                 if (! (personEntity.type === 'person_firstname' && ni.split(' ').length > 1) ) {
                                    return true;
                                 }
                            }
                            if (ni === normalize(personData.nombre, true)) {
                                return true;
                            }
                        }
                        return false;
                    },
                    action: (ni, ent) => {
                        const person = ent.find(e => e.type.startsWith('person_')).data;
                        conversationContext.lastPerson = person;
                        conversationContext.lastLocation = null; conversationContext.lastPuesto = null;

                        if (checkKeywords(ni, 'telefono')) return formatPersonInfo(person, 'telefono');
                        if (checkKeywords(ni, 'correo')) return formatPersonInfo(person, 'correo');
                        if (checkKeywords(ni, 'puesto')) return formatPersonInfo(person, 'puesto');
                        if (checkKeywords(ni, 'ubicacion')) return formatPersonInfo(person, 'ubicacion');
                        return formatPersonInfo(person, 'full');
                    }
                },
                {
                    name: "get_location_specific_or_full",
                    condition: (ni, ent) => {
                        const locations = ent.filter(e => e.type.startsWith('location_'));
                        if (locations.length !== 1) return false;
                        const locEntity = locations[0];
                        const specificInfoKeywords = ['ambito', 'direccion_loc', 'personas_en_loc'];
                        const hasInfoKeyword = specificInfoKeywords.some(kw => checkKeywords(ni, kw));
                        let locationNamePart = ni;
                        if (hasInfoKeyword) {
                            specificInfoKeywords.forEach(kw => {
                                CONFIG_INTENT_SYNONYMS[kw]?.forEach(syn => {
                                    locationNamePart = locationNamePart.replace(new RegExp(normalize(syn), 'gi'), '');
                                });
                            });
                            locationNamePart = locationNamePart.replace(/\bde\b/gi, '').trim();
                        }
                        const normalizedLocationName = normalize(locationNamePart, true);
                        const normalizedEntityName = normalize(locEntity.matchedKey, true);
                        const locationNameInQuery = normalizedEntityName.split(' ').every(part =>
                            normalizedLocationName.includes(part)
                        );
                        if (hasInfoKeyword && locationNameInQuery && normalizedLocationName) {
                            return true;
                        }
                        const isStrongLocationQuery = (normalizedEntityName === normalizedLocationName ||
                                                     normalizedEntityName.startsWith(normalizedLocationName)) &&
                                                    locEntity.length >= normalizedLocationName.split(' ').length && normalizedLocationName;
                        return isStrongLocationQuery;
                    },
                    action: (ni, ent) => {
                        const location = ent.find(e => e.type.startsWith('location_')).data;
                        conversationContext.lastLocation = location; conversationContext.lastPerson = null; conversationContext.lastPuesto = null;
                        if (checkKeywords(ni, 'ambito')) return formatLocationInfo(location, 'ambitos');
                        if (checkKeywords(ni, 'direccion_loc')) return formatLocationInfo(location, 'direccion');
                        if (checkKeywords(ni, 'personas_en_loc')) return formatLocationInfo(location, 'personas');
                        return formatLocationInfo(location, 'full');
                    }
                },
                {
                    name: "compare_puesto_personnel_count",
                    condition: (ni, ent) => {
                        const puestos = ent.filter(e => e.type.startsWith('puesto_') || e.type.startsWith('puesto_alias'));
                        return (ni.includes(" o ") || ni.includes(" √≥ ") || ni.includes(" versus ") || ni.includes(" vs ")) &&
                               checkKeywords(ni, 'comparar_mas') &&
                               puestos.length >= 2 &&
                               new Set(puestos.map(p => p.data.nombre_puesto || p.originalKey)).size >= 2;
                    },
                    action: (ni, ent) => {
                        const puestos = ent.filter(e => e.type.startsWith('puesto_') || e.type.startsWith('puesto_alias'));
                        const uniquePuestosData = [];
                        const seenPuestos = new Set();
                        for (const pEntity of puestos) {
                            const pName = pEntity.data.nombre_puesto || pEntity.originalKey;
                            if (!seenPuestos.has(pName)) {
                                uniquePuestosData.push(pEntity.data);
                                seenPuestos.add(pName);
                            }
                            if (uniquePuestosData.length === 2) break;
                        }
                        if (uniquePuestosData.length < 2) return "Necesito al menos dos puestos diferentes para comparar.";
                        const puesto1Data = uniquePuestosData[0];
                        const puesto2Data = uniquePuestosData[1];
                        const normPuesto1 = normalize(puesto1Data.nombre_puesto || puesto1Data.originalKey, true);
                        const normPuesto2 = normalize(puesto2Data.nombre_puesto || puesto2Data.originalKey, true);
                        const count1 = allPersons.filter(p => p.puesto && normalize(p.puesto, true).includes(normPuesto1) && p.nombre.toLowerCase() !== PENDING_NOM_LOWER).length;
                        const count2 = allPersons.filter(p => p.puesto && normalize(p.puesto, true).includes(normPuesto2) && p.nombre.toLowerCase() !== PENDING_NOM_LOWER).length;
                        const displayPuesto1 = puesto1Data.nombre_puesto || puesto1Data.originalKey;
                        const displayPuesto2 = puesto2Data.nombre_puesto || puesto2Data.originalKey;
                        if (count1 > count2) return `Hay m√°s personal con el puesto **${displayPuesto1}** (${count1}) que **${displayPuesto2}** (${count2}).`;
                        if (count2 > count1) return `Hay m√°s personal con el puesto **${displayPuesto2}** (${count2}) que **${displayPuesto1}** (${count1}).`;
                        if (count1 === 0 && count2 === 0) return `No encontr√© personal asignado ni para **${displayPuesto1}** ni para **${displayPuesto2}**.`;
                        return `Hay la misma cantidad de personal para **${displayPuesto1}** (${count1}) y **${displayPuesto2}** (${count2}).`;
                    }
                },
                {
                    name: "compare_location_personnel_count",
                    condition: (ni, ent) => {
                        return checkKeywords(ni, 'comparar_mas') &&
                               (ni.includes("base") || ni.includes("centro") || ni.includes("ubicacion")) &&
                               checkKeywords(ni, 'personas_en_loc');
                    },
                    action: (ni, ent) => {
                        if (allLocations.length === 0) return "No tengo datos de ubicaciones para comparar.";
                        let maxPersonnel = -1;
                        let locationsWithMax = [];
                        allLocations.forEach(loc => {
                            const personnelCount = allPersons.filter(p => p.ubicacion === loc.nombre_centro && p.nombre.toLowerCase() !== PENDING_NOM_LOWER).length;
                            if (personnelCount > maxPersonnel) {
                                maxPersonnel = personnelCount;
                                locationsWithMax = [loc.nombre_centro];
                            } else if (personnelCount === maxPersonnel && personnelCount > 0) {
                                locationsWithMax.push(loc.nombre_centro);
                            }
                        });
                        if (maxPersonnel <= 0 || locationsWithMax.length === 0) return "No pude determinar qu√© ubicaci√≥n tiene m√°s personal o ninguna tiene personal asignado.";
                        if (locationsWithMax.length === 1) return `La ubicaci√≥n con m√°s personal asignado es **${locationsWithMax[0]}** (con ${maxPersonnel} persona${maxPersonnel > 1 ? 's' : ''}).`;
                        return `Las ubicaciones con m√°s personal asignado (con ${maxPersonnel} persona${maxPersonnel > 1 ? 's' : ''} cada una) son: **${locationsWithMax.join(', ')}**.`;
                    }
                },
                {
                    name: "list_all_puestos",
                    condition: (ni, ent) => {
                        return checkKeywords(ni, 'lista') &&
                               (ni.includes("puesto") || ni.includes("cargo") || ni.includes("rol")) &&
                               ent.filter(e => e.type.startsWith('puesto_')).length === 0;
                    },
                    action: (ni, ent) => {
                        const puestoCounts = new Map();
                        allPersons
                            .filter(p => p.puesto && p.puesto.toLowerCase() !== PENDING_NOM_LOWER && p.nombre.toLowerCase() !== PENDING_NOM_LOWER)
                            .forEach(p => {
                                puestoCounts.set(p.puesto, (puestoCounts.get(p.puesto) || 0) + 1);
                            });
                        if (puestoCounts.size === 0) return "No hay puestos registrados con personal asignado (aparte de los pendientes).";
                        const sortedPuestos = Array.from(puestoCounts.entries()).sort((a, b) => a[0].localeCompare(b[0]));
                        const list = sortedPuestos.map(([puesto, count]) => `- ${puesto} (${count} persona${count > 1 ? 's' : ''})`).join('\n');
                        return `Estos son los puestos registrados con personal (${sortedPuestos.length}):\n${list}`;
                    }
                },
                {
                    name: "list_all_locations",
                    condition: (ni) => {
                        return checkKeywords(ni, 'lista') &&
                               (ni.includes("ubicacion") || ni.includes("ubicaciones") ||
                                ni.includes("base") || ni.includes("bases") ||
                                ni.includes("centro") || ni.includes("centros")) &&
                               ni.split(' ').length <= 4;
                    },
                    action: (ni, ent) => {
                        if (allLocations.length === 0) return "No tengo informaci√≥n de ubicaciones disponibles.";
                        const sortedLocations = [...allLocations].sort((a, b) =>
                            a.nombre_centro.localeCompare(b.nombre_centro)
                        );
                        const locationList = sortedLocations.map(loc =>
                            `- **${loc.nombre_centro}**`
                        ).join('\n');
                        return `Estas son todas las ubicaciones disponibles (${sortedLocations.length}):\n${locationList}`;
                    }
                },
                {
                    name: "general_query_or_unknown",
                    condition: () => true,
                    action: (ni, ent, ctx, originalInputString) => {
                        if (ent.length > 0) {
                            const persons = ent.filter(e => e.type.startsWith('person_') && e.type !== 'person_pending');
                            const locations = ent.filter(e => e.type.startsWith('location_'));
                            const puestos = ent.filter(e => e.type.startsWith('puesto_'));

                            if (persons.length > 0 && (ent[0].type.startsWith('person_') || persons.length >= locations.length + puestos.length)) {
                                const score = (pEntity, query, originalQueryNormalized) => {
                                    let s = 0;
                                    const normFullName = normalize(pEntity.data.nombre, true);
                                    const queryWordsOriginal = originalQueryNormalized.split(' ').filter(w => w.length > 1 && !COMMON_WORDS.has(w));
                                    if (normFullName === originalQueryNormalized) s += 1000;
                                    if (pEntity.matchedKey === query) s += pEntity.length * 50;
                                    let nameQueryPart = originalQueryNormalized;
                                    const infoKeywords = ['telefono de', 'correo de', 'puesto de', 'ubicacion de', 'informacion de', 'datos de', 'quien es'];
                                    let isInfoRequest = false;
                                    for (const kw of infoKeywords) {
                                        const normKw = normalize(kw);
                                        if (originalQueryNormalized.includes(normKw)) {
                                            nameQueryPart = originalQueryNormalized.replace(new RegExp(normKw + "\\s?(el|la|los|las)?\\s?", "gi"), '').trim();
                                            isInfoRequest = true;
                                            break;
                                        }
                                    }
                                    if (isInfoRequest && nameQueryPart) {
                                        if (normFullName === nameQueryPart) s += 800;
                                        else if (normFullName.includes(nameQueryPart) && nameQueryPart.split(' ').length >= 2) s += 400 + nameQueryPart.split(' ').length * 50;
                                    }
                                    let matchedWordCount = 0;
                                    queryWordsOriginal.forEach(word => {
                                        if (normFullName.includes(word)) {
                                            s += 30; matchedWordCount++;
                                            if (normFullName.split(' ').indexOf(word) === 0) s += 15;
                                            if (normFullName.split(' ').includes(word) && normFullName.split(' ').indexOf(word) > 0) s += 10;
                                        }
                                    });
                                    if (matchedWordCount === queryWordsOriginal.length && queryWordsOriginal.length > 0) s+= matchedWordCount * 10;
                                    const typeBonuses = {'person_full': 150, 'person_name_two_lastnames': 120, 'person_name_first_compound_lastname': 120, 'person_name_firstlastname': 100, 'person_all_lastnames': 80, 'person_first_lastname_alone': 50, 'person_last_lastname_alone': 40, 'person_firstname': 20 };
                                    s += typeBonuses[pEntity.type] || 0;
                                    s += (pEntity.relevance || 0) * 50;
                                    if (!isInfoRequest && originalQueryNormalized === normFullName) s += 200;
                                    if (!isInfoRequest && originalQueryNormalized.length > normFullName.length + 5 && !normFullName.startsWith(originalQueryNormalized)) s -= 50;
                                    if (normFullName.split(' ').length < 2 && queryWordsOriginal.length <=1 ) s *= 0.8;
                                    if (pEntity.originalKey) s += pEntity.originalKey.length * 2;
                                    const compoundNameMarkers = ["de la", "del", "de el", "de los", "de las"];
                                    if (compoundNameMarkers.some(marker => normFullName.includes(marker)) && compoundNameMarkers.some(marker => originalQueryNormalized.includes(marker))) s += 60;
                                    if (pEntity.matchedKey === query && normFullName.includes(query)) s += pEntity.length * 15;
                                    return s;
                                };
                                const sortedPersons = [...persons].sort((a,b) => score(b, b.matchedKey, ni) - score(a, a.matchedKey, ni));
                                const bestPersonMatch = sortedPersons[0];
                                const secondBestMatch = sortedPersons.length > 1 ? sortedPersons[1] : null;
                                const scoreBest = bestPersonMatch ? score(bestPersonMatch, bestPersonMatch.matchedKey, ni) : -1;
                                const scoreSecond = secondBestMatch ? score(secondBestMatch, secondBestMatch.matchedKey, ni) : -1;
                                const MIN_SCORE_THRESHOLD = 80;
                                const CLEAR_WINNER_FACTOR = 1.6;
                                const CLEAR_WINNER_DIFFERENCE = 180;
                                let isClearWinner = bestPersonMatch && scoreBest >= MIN_SCORE_THRESHOLD &&
                                                    (scoreSecond === -1 || scoreBest > scoreSecond * CLEAR_WINNER_FACTOR || scoreBest - scoreSecond > CLEAR_WINNER_DIFFERENCE);

                                if (isClearWinner) {
                                    conversationContext.lastPerson = bestPersonMatch.data;
                                    conversationContext.lastLocation = null; conversationContext.lastPuesto = null;
                                    return formatPersonInfo(bestPersonMatch.data);
                                } else if (persons.length > 0 && scoreBest >= MIN_SCORE_THRESHOLD / 1.5) {
                                    const topOptionsData = sortedPersons.slice(0, Math.min(3, sortedPersons.length))
                                                                .filter(p => score(p, p.matchedKey, ni) >= MIN_SCORE_THRESHOLD / 2);
                                    if (topOptionsData.length > 1) {
                                        let responseText = `Encontr√© varias personas que podr√≠an coincidir con "**${originalInputString}**". ¬øA cu√°l te refieres?`;
                                        const personBubbles = topOptionsData.map(pEntity => ({
                                            label: `${pEntity.data.nombre} (${pEntity.data.puesto || 'N/A'})`,
                                            queryValue: pEntity.data.nombre
                                        }));
                                        setTimeout(() => appendOptionBubbles(personBubbles, 'person'), 50);
                                        conversationContext.clear();
                                        return responseText;
                                    } else if (topOptionsData.length === 1 && !isClearWinner) {
                                        conversationContext.lastPerson = topOptionsData[0].data;
                                        return formatPersonInfo(topOptionsData[0].data) + "\n(Si no es la persona correcta, por favor, s√© m√°s espec√≠fico)";
                                    }
                                }
                            }
                            else if (locations.length > 1 && (ent[0].type.startsWith('location_') || locations.length > puestos.length)) {
                                let originalAction = "";
                                const originalQueryLC = originalInputString.toLowerCase();

                                if (originalQueryLC.includes("personal en") || originalQueryLC.includes("gente en") || originalQueryLC.includes("trabajadores en") || originalQueryLC.includes("quien esta en") || originalQueryLC.includes("quienes trabajan")) {
                                    originalAction = "Personal en";
                                } else if (originalQueryLC.includes("direccion de") || originalQueryLC.includes("direcci√≥n")) {
                                    originalAction = "Direcci√≥n de";
                                } else if (originalQueryLC.includes("ambito de") || originalQueryLC.includes("√°mbito")) {
                                    originalAction = "√Åmbito de";
                                } else if (originalQueryLC.includes("mapa de")) {
                                    originalAction = "Mapa de";
                                }
                                
                                const sortedLocations = [...locations].sort((a,b) => {
                                    const nameA = normalize(a.data.nombre_centro, true);
                                    const nameB = normalize(b.data.nombre_centro, true);
                                    let queryPart = ni;
                                    if (originalAction) {
                                        queryPart = ni.replace(normalize(originalAction.split(" ")[0]), "").trim();
                                    }
                                    const scoreA = nameA.includes(queryPart) ? nameA.length : 0;
                                    const scoreB = nameB.includes(queryPart) ? nameB.length : 0;
                                    if (scoreB !== scoreA) return scoreB - scoreA;
                                    
                                    if (b.length !== a.length) return b.length - a.length;
                                    return (b.relevance || 0) - (a.relevance || 0);
                                });

                                if (originalAction || (sortedLocations.length > 0 && ent[0].type.startsWith('location_'))) {
                                    let responseText = `Encontr√© varias ubicaciones que podr√≠an coincidir con "**${originalInputString}**". ¬øA cu√°l te refieres?`;
                                    const locationBubbles = sortedLocations.slice(0, 3).map(locEntity => {
                                        let queryValue;
                                        if (originalAction) {
                                            queryValue = `${originalAction} ${locEntity.data.nombre_centro}`;
                                        } else {
                                            queryValue = locEntity.data.nombre_centro;
                                        }
                                        return {
                                            label: locEntity.data.nombre_centro,
                                            queryValue: queryValue
                                        };
                                    });
                                    setTimeout(() => appendOptionBubbles(locationBubbles, 'location'), 50);
                                    conversationContext.clear();
                                    return responseText;
                                }
                            }
                            else if (puestos.length > 1 && persons.length === 0 && locations.length === 0 && ent[0].type.startsWith('puesto_')) {
                                const sortedPuestosEnt = [...puestos].sort((a, b) => {
                                    const nameA = a.data.nombre_puesto || a.originalKey || "";
                                    const nameB = b.data.nombre_puesto || b.originalKey || "";
                                    return nameB.length - nameA.length;
                                });
                                const topPuestos = sortedPuestosEnt.slice(0, 3);
                                const uniqueTopPuestos = [];
                                const addedNames = new Set();
                                for(const pEntity of topPuestos) {
                                    const pName = pEntity.data.nombre_puesto || pEntity.originalKey;
                                    if (pName && !addedNames.has(pName) && ni.includes(normalize(pName,true))) {
                                        uniqueTopPuestos.push(pEntity);
                                        addedNames.add(pName);
                                    }
                                }
                                if (uniqueTopPuestos.length > 1) {
                                    let responseText = `Tu consulta sobre "**${originalInputString}**" es un poco ambigua respecto al puesto. ¬øTe refieres a:`;
                                    const puestoBubbles = uniqueTopPuestos.map(pEntity => ({
                                        label: pEntity.data.nombre_puesto || pEntity.originalKey,
                                        queryValue: pEntity.data.nombre_puesto || pEntity.originalKey
                                    }));
                                    setTimeout(() => appendOptionBubbles(puestoBubbles, 'puesto'), 50);
                                    conversationContext.clear();
                                    return responseText;
                                } else if (uniqueTopPuestos.length === 1) {
                                    conversationContext.lastPuesto = uniqueTopPuestos[0].data;
                                    return getIntentResponse(ni, [uniqueTopPuestos[0]], 'find_person_by_role', originalInputString);
                                }
                            }


                            let responseParts = ["He encontrado varias cosas relacionadas (demasiado ambiguo para \"**" + originalInputString + "**\"):" ];
                            let addedToResponse = new Set();
                            let countDisplayed = 0;
                            for (const e of ent) {
                                if (countDisplayed >= 3) break;
                                const dataSignature = JSON.stringify(e.data);
                                if (!addedToResponse.has(dataSignature)) {
                                    if (e.type.startsWith('person_')) responseParts.push(`  - Persona: **${e.data.nombre}** (match: '${e.matchedKey}')`);
                                    else if (e.type.startsWith('location_')) responseParts.push(`  - Ubicaci√≥n: **${e.data.nombre_centro}** (match: '${e.matchedKey}')`);
                                    else if (e.type.startsWith('puesto_')) responseParts.push(`  - Puesto: **${e.data.nombre_puesto || e.originalKey}** (match: '${e.matchedKey}')`);
                                    addedToResponse.add(dataSignature);
                                    countDisplayed++;
                                }
                            }

                            if (responseParts.length > 1 && addedToResponse.size > 1) {
                                responseParts.push("Por favor, s√© m√°s espec√≠fico o pregunta por una sola cosa a la vez.");
                                return responseParts.join('\n');
                            } else if (ent.length > 0 && addedToResponse.size === 1) {
                                const singleEntity = ent.find(e => JSON.stringify(e.data) === Array.from(addedToResponse)[0]);
                                 if (singleEntity.type.startsWith('person_')) { conversationContext.lastPerson = singleEntity.data; return formatPersonInfo(singleEntity.data); }
                                 if (singleEntity.type.startsWith('location_')) { conversationContext.lastLocation = singleEntity.data; return formatLocationInfo(singleEntity.data); }
                                 if (singleEntity.type.startsWith('puesto_')) { conversationContext.lastPuesto = singleEntity.data; return getIntentResponse(ni, [singleEntity], 'find_person_by_role', originalInputString);}
                            }
                        }

                        if (ent.length === 1) {
                            const singleEntity = ent[0];
                             if (singleEntity.type.startsWith('person_')) { conversationContext.lastPerson = singleEntity.data; return formatPersonInfo(singleEntity.data); }
                             if (singleEntity.type.startsWith('location_')) { conversationContext.lastLocation = singleEntity.data; return formatLocationInfo(singleEntity.data); }
                             if (singleEntity.type.startsWith('puesto_')) {
                                if (ni.split(' ').length <=3 && normalize(singleEntity.data.nombre_puesto || singleEntity.originalKey, true) === ni) {
                                     conversationContext.lastPuesto = singleEntity.data;
                                     return getIntentResponse(ni, [singleEntity], 'find_person_by_role', originalInputString);
                                }
                             }
                        }

                        return 'Lo siento, no he entendido bien tu pregunta sobre "**' + originalInputString + '**". Prueba a reformularla o escribe "ayuda".';
                    }
                }
            ];
        }

        function getIntentResponse(normalizedInput, entities, specificIntent, originalInput) {
            if (specificIntent === 'find_person_by_role') {
                const puestosEntities = entities.filter(e => e.type.startsWith('puesto_') || e.type.startsWith('puesto_alias'));
                let targetPuestoNorm = '';
                let originalPuestoQuery = '';
                let mainPuestoEntity = null;

                if (puestosEntities.length > 0) {
                    mainPuestoEntity = puestosEntities.sort((a,b) => (b.data.nombre_puesto || b.originalKey || "").length - (a.data.nombre_puesto || a.originalKey || "").length)[0];
                } else if (entities.length > 0 && entities[0].type.startsWith('puesto_')) {
                    mainPuestoEntity = entities[0];
                }


                if (mainPuestoEntity && (mainPuestoEntity.data.nombre_puesto || mainPuestoEntity.originalKey)) {
                    targetPuestoNorm = normalize(mainPuestoEntity.data.nombre_puesto || mainPuestoEntity.originalKey, true);
                    originalPuestoQuery = mainPuestoEntity.data.nombre_puesto || mainPuestoEntity.originalKey;
                } else {
                    return "No pude identificar un puesto para buscar.";
                }

                if (targetPuestoNorm) {
                    const peopleWithRole = allPersons.filter(p =>
                        p.puesto && normalize(p.puesto, true).includes(targetPuestoNorm) &&
                        p.nombre.toLowerCase() !== PENDING_NOM_LOWER
                    );
                    if (peopleWithRole.length > 0) {
                        const displayPuesto = originalPuestoQuery;
                        if (peopleWithRole.length === 1 && (checkKeywords(normalizedInput, 'quien_es') && !normalizedInput.toLowerCase().includes("lista")) || (mainPuestoEntity && normalizedInput === normalize(mainPuestoEntity.originalKey, true) && peopleWithRole.length ===1 )) {
                            conversationContext.lastPerson = peopleWithRole[0];
                            if (mainPuestoEntity) conversationContext.lastPuesto = mainPuestoEntity.data;
                            return `El/La **${displayPuesto}** es ${formatPersonInfo(peopleWithRole[0])}`;
                        }
                        const list = peopleWithRole.map(p => `- **${p.nombre}** (${p.ubicacion || 'Ubicaci√≥n no especificada'})`).join('\n');
                        if (mainPuestoEntity) conversationContext.lastPuesto = mainPuestoEntity.data;
                        return `Personas con el puesto de **${displayPuesto}** (o similar):\n${list}`;
                    }
                    return `No encontr√© a nadie con el puesto "**${originalPuestoQuery}**" o est√° pendiente de nombramiento.`;
                }
                return "No pude identificar un puesto espec√≠fico. Intenta 'Qui√©n es el Jefe de √Årea' o 'lista de puestos'.";
            }
            return 'Error interno: Intenci√≥n espec√≠fica no manejada: ' + specificIntent;
        }


        function processInput(originalInputString) {
            try {
                const normalizedInput = normalize(originalInputString);
                let entities = findEntities(normalizedInput);

                console.log("Input:", originalInputString, "Normalized:", normalizedInput, "Entities:", entities.map(e => ({type: e.type, key: e.matchedKey, data_orig: e.originalKey, data_name: e.data.nombre || e.data.nombre_centro || (e.data.nombre_puesto || e.originalKey) , length: e.length, rel: e.relevance?.toFixed(2) })));
                const existingOptionBubbles = document.getElementById('optionBubblesContainer');
                if (existingOptionBubbles) existingOptionBubbles.remove();

                for (const rule of intentionRules) {
                    if (rule.condition(normalizedInput, entities, conversationContext, originalInputString)) {
                        console.log(`Intenci√≥n detectada: ${rule.name}`);
                        if (!checkKeywords(normalizedInput, 'y_su') && !checkKeywords(normalizedInput, 'solo_eso', true)) {
                            if (rule.name !== "context_acknowledged" && !rule.name.startsWith("context_")) {
                                if (!rule.name.startsWith("get_person_") &&
                                    !rule.name.startsWith("get_location_") &&
                                    !rule.name.startsWith("find_person_by_role_direct") &&
                                    !rule.name.startsWith("find_person_by_phone") &&
                                    rule.name !== "general_query_or_unknown" &&
                                    rule.name !== "find_specific_person_by_role_and_location"
                                   ) {
                                }
                            }
                        }
                        const response = rule.action(normalizedInput, entities, conversationContext, originalInputString);
                        return response;
                    }
                }
                return 'Lo siento, no pude procesar tu solicitud (ninguna regla coincidi√≥ con "**' + originalInputString + '**"). Intenta reformularla.';
            } catch (error) {
                console.error("Error al procesar la entrada:", error, error.stack);
                return `¬°Ups! Algo sali√≥ mal: "${error.message}". Intenta de nuevo.`;
            }
        }

        function formatPersonInfo(person, requestedInfo = 'full') {
            if (!person || !person.nombre) {
                return "No se encontr√≥ informaci√≥n de la persona solicitada.";
            }
            const isPteNombre = person.nombre.toLowerCase() === PENDING_NOM_LOWER;
            const isPtePuesto = person.puesto && person.puesto.toLowerCase() === PENDING_NOM_LOWER;

            if (isPteNombre && isPtePuesto) {
                 const ubicacionInfo = person.ubicacion ? ` en ${person.ubicacion}` : '';
                return `Hay un puesto actualmente **pendiente de nombramiento**${ubicacionInfo}. No se especifica el rol.`;
            }
            if (isPteNombre) {
                 return `Hay un puesto de **${person.puesto}** actualmente **pendiente de nombramiento** en ${person.ubicacion}.`;
            }

            let info = [];
            const addInfo = (label, value) => {
                if (value && value.toLowerCase() !== PENDING_NOM_LOWER) info.push(`${label}: ${value}`);
                else if (value && value.toLowerCase() === PENDING_NOM_LOWER && (requestedInfo ==='full' || label.toLowerCase() === requestedInfo )) info.push(`${label}: **Pendiente**`);
            };

            let title = `**${person.nombre}**`;

            if (requestedInfo === 'full' || requestedInfo === 'puesto') addInfo('Puesto', person.puesto);
            if (requestedInfo === 'full' || requestedInfo === 'ubicacion') addInfo('Ubicaci√≥n', person.ubicacion);
            if (requestedInfo === 'full' || requestedInfo === 'correo') addInfo('Correo', person.correo);
            if (requestedInfo === 'full' || requestedInfo === 'telefono') addInfo('Tel√©fono', person.telefono);

            if (info.length === 0) {
                const specificDataField = requestedInfo.toLowerCase();
                const specificDataValue = person[specificDataField];
                if (requestedInfo !== 'full' && specificDataValue && specificDataValue.toLowerCase() === PENDING_NOM_LOWER) {
                    return `La informaci√≥n de "${requestedInfo}" para **${person.nombre}** est√° **pendiente**.`;
                }
                if (requestedInfo !== 'full') {
                    return `No tengo informaci√≥n sobre "${requestedInfo}" para **${person.nombre}** o est√° pendiente.`;
                }
                if (requestedInfo === 'full' && Object.values(person).every(val => typeof val === 'string' && val.toLowerCase() === PENDING_NOM_LOWER || val === person.nombre || val === person.ubicacion)) {
                     return `**${person.nombre}**: Toda la informaci√≥n de contacto y puesto est√° actualmente **pendiente**. Se encuentra en ${person.ubicacion}.`;
                }
                return `No tengo m√°s detalles para **${person.nombre}** en este momento.`;
            }
            return title + (info.length > 0 ? ':\n  ' + info.join('\n  ') : '.');
        }

        function formatLocationInfo(location, requestedInfo = 'full') {
             if (!location || !location.nombre_centro) {
                return "No se encontr√≥ informaci√≥n de la ubicaci√≥n solicitada.";
            }
            let parts = [`Informaci√≥n sobre **${location.nombre_centro}**:`];
            let infoFound = false;

            if (requestedInfo === 'full' || requestedInfo === 'ambitos') {
                if (location.ambitos_mantenimiento && location.ambitos_mantenimiento.length > 0) {
                    parts.push(`  √Åmbito de mantenimiento:\n    - ${location.ambitos_mantenimiento.join('\n    - ')}`);
                    infoFound = true;
                } else if (requestedInfo === 'ambitos') {
                     parts.push(`  No tengo informaci√≥n sobre el √°mbito de mantenimiento.`);
                     infoFound = true;
                }
            }
            if (requestedInfo === 'full' || requestedInfo === 'personas') {
                 const peopleInLoc = allPersons.filter(p => p.ubicacion === location.nombre_centro && (p.nombre && p.nombre.toLowerCase() !== PENDING_NOM_LOWER));
                const ptePeopleInLoc = allPersons.filter(p => p.ubicacion === location.nombre_centro && (p.nombre && p.nombre.toLowerCase() === PENDING_NOM_LOWER));

                if (peopleInLoc.length > 0) {
                    const sortedPeople = [...peopleInLoc].sort((a, b) => {
                        const isAJefe = a.puesto && a.puesto.toLowerCase().includes('jefe de base') ? -1 : (a.puesto && a.puesto.toLowerCase().includes('jefe de area') ? 0 : 1);
                        const isBJefe = b.puesto && b.puesto.toLowerCase().includes('jefe de base') ? -1 : (b.puesto && b.puesto.toLowerCase().includes('jefe de area') ? 0 : 1);
                        if (isAJefe !== isBJefe) return isAJefe - isBJefe;
                        return (a.nombre || "").localeCompare(b.nombre || "");
                    });

                    const list = sortedPeople.map(p => `    - **${p.nombre}** (${p.puesto && p.puesto.toLowerCase() !== PENDING_NOM_LOWER ? p.puesto : 'Puesto pendiente'})`).join('\n');
                    parts.push(`  Personal asignado (${peopleInLoc.length}):\n${list}`);
                    infoFound = true;
                }

                if (ptePeopleInLoc.length > 0) {
                    const pteList = ptePeopleInLoc.map(p => `    - **${p.puesto !== PENDING_NOM_LOWER ? p.puesto : 'Rol sin especificar'}** (Pendiente de nombramiento)`).join('\n');
                    parts.push(`  Puestos pendientes de nombramiento (${ptePeopleInLoc.length}):\n${pteList}`);
                    infoFound = true;
                }

                if (peopleInLoc.length === 0 && ptePeopleInLoc.length === 0 && requestedInfo === 'personas') {
                     parts.push(`  No encontr√© personal asignado ni pendiente en esta ubicaci√≥n.`);
                     infoFound = true;
                }
            }
            if (requestedInfo === 'full' || requestedInfo === 'direccion') {
                 if (location.direccion) {
                    parts.push(`  Direcci√≥n: ${location.direccion}`);
                    infoFound = true;
                 } else if (requestedInfo === 'direccion') {
                    parts.push(`  Direcci√≥n: No disponible.`);
                    infoFound = true;
                 }
                 if (location.enlace_google_maps) {
                    parts.push(`  Google Maps: <a href="${location.enlace_google_maps}" target="_blank" class="text-blue-600 hover:underline">${location.enlace_google_maps}</a>`);
                    infoFound = true;
                 }
            }
            if (!infoFound && requestedInfo === 'full') parts.push("  No tengo m√°s detalles espec√≠ficos para esta ubicaci√≥n.");
            else if (!infoFound && requestedInfo !== 'full') return `No tengo informaci√≥n sobre "${requestedInfo}" para **${location.nombre_centro}**.`;

            return parts.join('\n');
        }

        function appendMessage(sender, text) {
            const messageWrapper = document.createElement('div');
            messageWrapper.classList.add('message-wrapper', sender === 'user' ? 'user-message-wrapper' : 'bot-message-wrapper');

            const avatarElement = document.createElement('div');
            avatarElement.classList.add('message-avatar', 'flex', 'items-center', 'justify-center', 'text-2xl', 'bg-gray-200', 'rounded-full');
            avatarElement.textContent = sender === 'user' ? USER_AVATAR_EMOJI : BOT_AVATAR_EMOJI;

            const messageContentDiv = document.createElement('div');
            messageContentDiv.classList.add('message-content');

            let htmlText = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            htmlText = htmlText.replace(/\n/g, '<br>');
            htmlText = htmlText.replace(/(https?:\/\/(?:www\.)?google\.com\/maps\S+|https?:\/\/maps\.app\.goo\.gl\/\S+)/g, '<a href="$1" target="_blank" class="text-blue-600 hover:underline">$1</a>');

            messageContentDiv.innerHTML = htmlText;

            if (sender === 'user') {
                messageWrapper.appendChild(messageContentDiv);
                messageWrapper.appendChild(avatarElement);
            } else {
                messageWrapper.appendChild(avatarElement);
                messageWrapper.appendChild(messageContentDiv);
            }

            chatBox.appendChild(messageWrapper);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        function appendOptionBubbles(options, type = 'person') {
            const existingBubbles = document.getElementById('optionBubblesContainer');
            if (existingBubbles) existingBubbles.remove();

            const bubblesContainer = document.createElement('div');
            bubblesContainer.id = 'optionBubblesContainer';
            bubblesContainer.classList.add('flex', 'flex-wrap', 'gap-2', 'mb-3', 'pl-12');

            options.forEach(option => {
                const bubble = document.createElement('span');
                bubble.classList.add('help-bubble', 'option-bubble-item');
                bubble.textContent = option.label;

                bubble.addEventListener('click', () => {
                    userInput.value = option.queryValue;
                    handleUserInput();
                });
                bubblesContainer.appendChild(bubble);
            });

            if (options.length > 0) {
                chatBox.appendChild(bubblesContainer);
                chatBox.scrollTop = chatBox.scrollHeight;
            }
        }


        function showTypingIndicator() {
            if (!isTyping) {
                const typingWrapper = document.createElement('div');
                typingWrapper.classList.add('message-wrapper', 'bot-message-wrapper');
                typingWrapper.id = 'typingIndicatorWrapper';
                const avatarDiv = document.createElement('div');
                avatarDiv.classList.add('message-avatar', 'flex', 'items-center', 'justify-center', 'text-2xl', 'bg-gray-200', 'rounded-full');
                avatarDiv.textContent = BOT_AVATAR_EMOJI;
                typingWrapper.appendChild(avatarDiv);
                typingWrapper.appendChild(typingIndicatorElement);

                chatBox.appendChild(typingWrapper);
                chatBox.scrollTop = chatBox.scrollHeight;
                isTyping = true;
            }
        }
        function hideTypingIndicator() {
            const typingWrapper = document.getElementById('typingIndicatorWrapper');
            if (isTyping && typingWrapper) {
                if (typingWrapper.parentNode === chatBox) {
                    chatBox.removeChild(typingWrapper);
                }
                isTyping = false;
            }
        }

        function getRandomElement(arr) {
            if (!arr || arr.length === 0) return null;
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function getRandomPersonNameAndFirstLastName() {
            if (!allPersons || allPersons.length === 0) return null;
            const validPersons = allPersons.filter(p => p.nombre && p.nombre.toLowerCase() !== PENDING_NOM_LOWER && p.nombre.includes(' '));
            if (validPersons.length === 0) return null;
            const person = getRandomElement(validPersons);
            const parts = person.nombre.split(' ');
            return `${parts[0]} ${parts[1]}`;
        }

        function getRandomLocationName() {
            if (!allLocations || allLocations.length === 0) return null;
            const location = getRandomElement(allLocations);
            return location.nombre_centro;
        }

        function getRandomPuestoName() {
            if (!allPuestos || allPuestos.length === 0) return null;
            return getRandomElement(allPuestos);
        }


        function displayHelpBubbles() {
            helpBubblesContainer.innerHTML = '';
            const generatedQuestions = new Set();

            const templates = [
                { t: "Tel√©fono de {persona}", needs: ['persona'] },
                { t: "Correo de {persona}", needs: ['persona'] },
                { t: "Puesto de {persona}", needs: ['persona'] },
                { t: "Ubicaci√≥n de {persona}", needs: ['persona'] },
                { t: "Qui√©n es {persona}", needs: ['persona'] },
                { t: "Qui√©n es el {puesto} en {ubicacion}", needs: ['puesto', 'ubicacion'] },
                { t: "Personal en {ubicacion}", needs: ['ubicacion'] },
                { t: "√Åmbito de {ubicacion}", needs: ['ubicacion'] },
                { t: "Direcci√≥n de {ubicacion}", needs: ['ubicacion'] },
                { t: "{ubicacion} direcci√≥n", needs: ['ubicacion'] },
                { t: "Lista de T√©cnicos de Energ√≠a", static: true },
                { t: "Lista de todas las ubicaciones", static: true },
                { t: "Lista de todos los puestos", static: true },
                { t: "Informaci√≥n de {persona}", needs: ['persona'] },
                { t: "¬øQui√©nes son los Operadores CSI en CRC Albacete?", static: true },
                { t: "Operadores TME", static: true },
                { t: "Telemando", static: true },
                { t: "CSI", static: true },
                { t: "¬øHay alg√∫n T√©cnico II.SS.?", static: true },
                { t: "610165651", static: true },
                { t: "¬øQu√© base tiene m√°s personal?", static: true },
                { t: "¬øHay m√°s T√©cnicos de Energ√≠a o T√©cnicos II.SS.?", static: true }
            ];

            let attempts = 0;
            while (generatedQuestions.size < 20 && attempts < 60) {
                const templateObj = getRandomElement(templates);
                let question = templateObj.t;
                let possible = true;

                if (templateObj.static) {
                    // No action
                } else if (templateObj.needs) {
                    if (templateObj.needs.includes('persona')) {
                        const persona = getRandomPersonNameAndFirstLastName();
                        if (persona) question = question.replace('{persona}', persona);
                        else possible = false;
                    }
                    if (templateObj.needs.includes('ubicacion')) {
                        const ubicacion = getRandomLocationName();
                        if (ubicacion) question = question.replace('{ubicacion}', ubicacion);
                        else possible = false;
                    }
                    if (templateObj.needs.includes('puesto')) {
                        const puesto = getRandomPuestoName();
                         if (puesto && question.includes("{puesto}")) question = question.replace('{puesto}', puesto);
                         else if (!puesto && question.includes("{puesto}")) possible = false;
                    }
                }

                if (possible && !generatedQuestions.has(question) && !question.includes("{")) {
                    generatedQuestions.add(question);
                }
                attempts++;
            }

            const staticFallbacks = [
                "Tel√©fono de Mario Garc√≠a Aguado", "Correo de Javier Gambin", "Qui√©n es el Jefe de √Årea",
                "Personas en BM Villarrubia", "√Åmbito de BM Gabald√≥n", "Lista de todas las ubicaciones",
                "Lista de todos los puestos", "Operadores TME", "N√∫mero de tel√©fono de Iv√°n De La Paz Notario",
                "Email de Jes√∫s Valero N√∫√±ez", "Puesto de Pedro Luis Miguel S√°nchez", "Ubicaci√≥n de Esther Lorente Llenderrozas"
            ];
            let fallbackIndex = 0;
            while(generatedQuestions.size < 12 && fallbackIndex < staticFallbacks.length) {
                if(!generatedQuestions.has(staticFallbacks[fallbackIndex])) {
                    generatedQuestions.add(staticFallbacks[fallbackIndex]);
                }
                fallbackIndex++;
            }


            const finalQuestions = Array.from(generatedQuestions);
            finalQuestions.sort(() => Math.random() - 0.5);

            finalQuestions.slice(0, 20).forEach(qText => {
                const bubble = document.createElement('span');
                bubble.classList.add('help-bubble');
                bubble.textContent = qText;
                bubble.addEventListener('click', () => {
                    userInput.value = qText;
                    hideHelpBubbles();
                    handleUserInput();
                });
                helpBubblesContainer.appendChild(bubble);
            });
            helpBubblesContainer.classList.remove('hidden');
         }

        function hideHelpBubbles() {
             helpBubblesContainer.classList.add('hidden');
        }

        function clearChat() {
            chatBox.innerHTML = '';
            appendMessage('bot', INITIAL_BOT_MESSAGE);
            conversationContext.clear();
            hideHelpBubbles();
            const existingOptionBubbles = document.getElementById('optionBubblesContainer');
            if (existingOptionBubbles) existingOptionBubbles.remove();
            if(dataLoaded) userInput.focus();
        }

        helpButton.addEventListener('click', () => {
            if (!userInput.disabled) {
                const existingOptionBubbles = document.getElementById('optionBubblesContainer');
                if (existingOptionBubbles) existingOptionBubbles.remove();
                userInput.value = 'ayuda';
                handleUserInput();
            }
        });


        async function handleUserInput() {
            if (!dataLoaded) {
                appendMessage('bot', 'Los datos a√∫n no est√°n cargados. Por favor, espera.');
                return;
            }
            const input = userInput.value.trim();
            if (!input) return;

            appendMessage('user', input);
            userInput.value = '';

            const existingOptionBubbles = document.getElementById('optionBubblesContainer');
            if (existingOptionBubbles) existingOptionBubbles.remove();

            hideHelpBubbles();
            showTypingIndicator();

            setTimeout(() => {
                const botResponse = processInput(input);
                hideTypingIndicator();
                appendMessage('bot', botResponse);
            }, Math.random() * 300 + 150);
        }

        sendButton.addEventListener('click', handleUserInput);
        userInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleUserInput();
            }
        });
        clearChatButton.addEventListener('click', clearChat);

        defineIntentionRules();
        loadData();

    </script>
</body>
</html>