<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preg√∫ntame LAV ESTE - Mejorado v2.4 (Multi-Mejoras)</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body { scroll-behavior: smooth; }
        header {
            background: linear-gradient(to right, #ffffff, #f0f9f9, #ffffff);
            color: #333; padding: 20px; text-align: center;
        }
        header h1 { font-family: 'Montserrat', sans-serif; }
        .chat-container {
            max-width: 800px; margin: 20px auto; background-color: #e0f7fa;
            border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex; flex-direction: column; height: 75vh; 
            overflow: hidden;
        }
        .chat-box {
            flex-grow: 1; padding: 20px; overflow-y: auto; border-bottom: 1px solid #eee;
            background-color: #e0f7fa;
        }
        
        .message-wrapper {
            display: flex;
            margin-bottom: 15px;
            align-items: flex-end; 
        }
        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
        }
        .message-content {
            padding: 10px 15px; border-radius: 18px; 
            max-width: calc(80% - 50px); 
            white-space: pre-wrap; word-wrap: break-word;
            line-height: 1.5; 
        }

        .user-message-wrapper {
            justify-content: flex-end; 
        }
        .user-message-wrapper .message-avatar {
            margin-left: 10px;
            order: 1; 
        }
        .user-message-wrapper .message-content {
            background-color: #008080; color: white;
            border-bottom-right-radius: 5px;
            margin-left: auto; 
        }

        .bot-message-wrapper .message-avatar {
            margin-right: 10px;
        }
        .bot-message-wrapper .message-content {
            background-color: #e2e8f0; color: #333;
            border-bottom-left-radius: 5px;
        }

        .typing-indicator {
            display: flex; align-items: center; margin-bottom: 15px;
            align-self: flex-start; margin-right: auto; padding: 10px 15px;
            background-color: #e2e8f0; border-radius: 18px; max-width: 80%;
        }
        .typing-indicator span {
            height: 8px; width: 8px; margin: 0 2px; background-color: #718096; 
            display: block; border-radius: 50%; opacity: 0.4;
            animation: pulse 1.2s infinite ease-in-out;
        }
        .typing-indicator span:nth-child(1) { animation-delay: 0s; }
        .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes pulse { 0%, 100% { opacity: 0.3; transform: scale(0.8); } 50% { opacity: 1; transform: scale(1); } }
        
        .input-area { display: flex; padding: 15px; background-color: #b2ebf2; border-top: 1px solid #80deea; }
        .input-area input {
            flex-grow: 1; padding: 12px 15px; border: 1px solid #ccc;
            border-radius: 20px; margin-right: 10px; font-size: 1rem;
        }
        .input-area button {
            background-color: #005293; color: white; padding: 0 25px;
            border: none; border-radius: 20px; cursor: pointer;
            transition: background-color 0.3s ease; font-weight: 500;
            display: flex; align-items: center; justify-content: center;
        }
        .input-area button:hover { background-color: #003d6f; }
        .input-area button:disabled { background-color: #cccccc; cursor: not-allowed; }

        #clearChatButton .button-text, #helpButton .button-text {
            display: none; margin-left: 5px;
        }
        #clearChatButton:hover, #helpButton:hover {
            width: auto; padding: 0 15px; border-radius: 20px;
        }
        #clearChatButton:hover .button-text, #helpButton:hover .button-text {
            display: inline;
        }

        .help-bubbles-container {
            padding: 10px 15px; background-color: #f8f9fa;
            border-bottom: 1px solid #eee;
            max-height: 120px; overflow-y: auto; 
        }
        .help-bubble {
            cursor: pointer; transition: all 0.2s ease-in-out;
            font-size: 0.85rem; margin: 4px;
        }
        .help-bubble:hover { background-color: #cce7ff; border-color: #005293; color: #005293; transform: translateY(-1px); }
        
        .chat-box::-webkit-scrollbar, .help-bubbles-container::-webkit-scrollbar { width: 8px; }
        .chat-box::-webkit-scrollbar-track, .help-bubbles-container::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px;}
        .chat-box::-webkit-scrollbar-thumb, .help-bubbles-container::-webkit-scrollbar-thumb { background: #ccc; border-radius: 10px;}
        .chat-box::-webkit-scrollbar-thumb:hover, .help-bubbles-container::-webkit-scrollbar-thumb:hover { background: #aaa; }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div class="w-full min-w-full overflow-x-auto px-4 py-8">
        <header class="mb-4 text-center relative">
            <img src="https://www.adifaltavelocidad.es/documents/34745/2553140/Logo_Adif_AV_verde_351x170.png/aa356add-9b30-836e-8d9f-276eb02d17cf?t=1617203111419&download=true" alt="Logo Adif" class="absolute top-0 left-0 h-24">
            <img src="https://www.ineco.com/ineco/sites/default/files/2022-12/Logo%20Ineco.png" alt="Logo Ineco" class="absolute top-0 right-0 h-16 mt-2">
            <h1 class="text-5xl font-bold text-[#005293] mb-2 hover:text-[#003d6f] transition-colors">MANTENIMIENTO LAV ESTE</h1>
            <h2 class="text-3xl font-semibold text-[#008080]">Preg√∫ntame</h2>
        </header>

        <div class="bg-white shadow-lg rounded-lg p-4 mb-6 border border-gray-300">
            <div class="flex flex-col sm:flex-row justify-center items-center gap-4">
                <div class="flex gap-2 sm:gap-4">
                    <button onclick="window.location.href='index.html'" class="px-3 py-2 sm:px-4 bg-[#008080] text-white rounded-md hover:bg-[#005293] transition-colors text-sm sm:text-base">üë®‚Äçüë©‚Äçüëß‚Äçüë¶ ORGANIGRAMA</button>
                    <button onclick="window.location.href='directorio.html'" class="px-3 py-2 sm:px-4 bg-[#008080] text-white rounded-md hover:bg-[#005293] transition-colors text-sm sm:text-base">üìû DIRECTORIO</button>
                    <button onclick="window.location.href='mapa.html'" class="px-3 py-2 sm:px-4 bg-[#008080] text-white rounded-md hover:bg-[#005293] transition-colors text-sm sm:text-base">üåç MAPA</button>
                </div>
            </div>
        </div>

        <div class="chat-container">
            <div class="chat-box" id="chatBox">
                <!-- Mensajes iniciales se a√±adir√°n aqu√≠ -->
            </div>
            <div id="helpBubblesContainer" class="help-bubbles-container flex flex-wrap gap-2 bg-gray-50 hidden"></div>
            <div class="input-area">
                <button id="helpButton" title="Ayuda" class="bg-blue-500 text-white rounded-full w-10 h-10 flex items-center justify-center hover:bg-blue-700 transition-colors text-lg mr-2">
                    <i class="fas fa-question"></i> <span class="button-text">Ayuda</span>
                </button>
                <button id="clearChatButton" title="Limpiar chat" class="bg-gray-500 text-white rounded-full w-10 h-10 flex items-center justify-center hover:bg-gray-700 transition-colors text-lg mr-2">
                    <i class="fas fa-eraser"></i> <span class="button-text">Limpiar Chat</span>
                </button>
                <input type="text" id="userInput" placeholder="Cargando..." autocomplete="off" disabled>
                <button id="sendButton" title="Enviar pregunta" disabled>
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        const chatBox = document.getElementById('chatBox');
        const userInput = document.getElementById('userInput');
        const sendButton = document.getElementById('sendButton');
        const helpBubblesContainer = document.getElementById('helpBubblesContainer');
        const clearChatButton = document.getElementById('clearChatButton');
        const helpButton = document.getElementById('helpButton');

        let unifiedData = [];
        let allPersons = [];
        let allLocations = [];
        let entityIndex = new Map(); 
        const PENDING_NOM_LOWER = "pendiente de nombramiento";
        
        let conversationContext = {
            lastPerson: null,
            lastLocation: null,
            lastPuesto: null,
            clear: function() {
                this.lastPerson = null;
                this.lastLocation = null;
                this.lastPuesto = null;
            }
        };

        const USER_AVATAR_EMOJI = "üë§";
        const BOT_AVATAR_EMOJI = "ü§ñ";
        const INITIAL_BOT_MESSAGE = "¬°Hola! üëã Soy tu asistente virtual para el Mantenimiento LAV ESTE. Preg√∫ntame lo que necesites o escribe 'ayuda' para ver ejemplos.";

        let CONFIG_TYPO_CORRECTIONS = {};
        let CONFIG_INTENT_SYNONYMS = {};

        const SIMULATED_TYPOS_JSON = {
            // Correcciones de tel√©fono
            "teleono": "telefono", "telefno": "telefono", "telf": "telefono", "tlf": "telefono", 
            "nmero": "numero", "nummero": "numero", "telefonoo": "telefono", "tel√©fonoo": "telefono",
            "m√≥viles": "movil", "m√≥vil": "movil", "celulares": "celular", "celular": "movil",
            "extensi√≥n": "extension", "extensio": "extension", "ext": "extension",
            
            // Correcciones de ubicaci√≥n
            "ubicaion": "ubicacion", "ubicacoin": "ubicacion", "ubicaci√≥m": "ubicacion",
            "dondeesta": "donde esta", "dondeest√°": "donde esta", "donde": "donde",
            "localisacion": "localizacion", "localizaci√≥n": "localizacion", "localisaci√≥n": "localizacion",
            "uvicacion": "ubicacion", "ubiccacion": "ubicacion", "ubcacion": "ubicacion",
            "direcci√≥n": "direccion", "direccion": "direccion", "direncion": "direccion", "dierccion": "direccion",
            "emplazamiento": "ubicacion", "situacion": "ubicacion", "situaci√≥n": "ubicacion",
            
            // Correcciones de correo electr√≥nico
            "coreo": "correo", "corrreo": "correo", "emial": "email", "emeil": "email", 
            "correo electronico": "correo", "correo-e": "correo", "e-mail": "email",
            "mail": "email", "correo@": "correo", "@": "", "arroba": "",
            
            // Correcciones de personas
            "quien esla": "quien es la", "quienes": "quien es", "qien": "quien", "kienes": "quienes son", "kien": "quien",
            "el/la": "", "los/las": "", "un/una": "", "un": "", "una": "", "el": "", "la": "", "los": "", "las": "",
            "sr.": "", "sra.": "", "srta.": "", "d.": "", "da.": "", "d√±a.": "", "don": "", "do√±a": "",
            
            // Correcciones de puestos y cargos
            "tecnicos": "tecnico", "tecnicas": "tecnico", "tecnco": "tecnico", "t√©cnico": "tecnico", "t√©cnicos": "tecnico",
            "operadores": "operador", "operadoras": "operador", "operativa": "operativo", "operativos": "operativo",
            "jefes": "jefe", "gefe": "jefe", "gefa": "jefa", "jefas": "jefa", "jefesas": "jefa", "encargado": "jefe",
            "coordinador": "coordinacion", "coordinadores": "coordinacion", "coordinadora": "coordinacion",
            "responsable": "jefe", "responsables": "jefe", "director": "direccion", "directora": "direccion",
            "gerente": "gerencia", "subdirector": "subdireccion", "subdirectora": "subdireccion",
            "asistente": "asistencia", "asistentes": "asistencia", "ayudante": "asistente", "ayudantes": "asistente",
            
            // Correcciones de infraestructura
            "iiss": "ii.ss.", "is": "ii.ss.", "isss": "ii.ss.", "ii ss": "ii.ss.", "i.i.s.s.": "ii.ss.",
            "infra": "infraestructura", "infr": "infraestructura", "infraestructural": "infraestructura",
            "vias": "via", "v√≠a": "via", "v√≠as": "via", "linea": "linea", "l√≠nea": "linea", "lineas": "linea", "l√≠neas": "linea",
            "estacion": "estacion", "estaci√≥n": "estacion", "estaciones": "estacion",
            "tunel": "tunel", "t√∫nel": "tunel", "tuneles": "tunel", "t√∫neles": "tunel",
            "puente": "puente", "puentes": "puente", "viaducto": "puente", "viaductos": "puente",
            
            // Correcciones de ubicaciones espec√≠ficas
            "bm ": "base de mantenimiento ", "b.m.": "base de mantenimiento", "bm": "base de mantenimiento", "base mtto": "base de mantenimiento",
            "crc ": "centro de regulacion y control ", "c.r.c.": "centro de regulacion y control", "crc": "centro de regulacion y control",
            "et ": "estacion de transformacion ", "e.t.": "estacion de transformacion", "et": "estacion de transformacion",
            "ctr ": "centro ", "ctr.": "centro", "ctr": "centro", "cntr": "centro", "cntro": "centro",
            "oficina": "oficina", "oficinas": "oficina", "despacho": "oficina", "despachos": "oficina",
            "almacen": "almacen", "almac√©n": "almacen", "almacenes": "almacen", "deposito": "almacen", "dep√≥sito": "almacen",
            
            // Correcciones de t√©rminos generales
            "ambitos": "ambito", "ambto": "ambito", "amvito":"ambito", "√°mbito": "ambito", "ambitos": "ambito",
            "persoanl": "personal", "personla": "personal", "empleados": "personal", "trabajadores": "personal", "plantilla": "personal",
            "lisat": "lista", "listdo": "listado", "enumeracion": "lista", "enumeraci√≥n": "lista", "enumerar": "lista",
            "informaci√≥n": "informacion", "informacion": "informacion", "info": "informacion", "dato": "informacion", "datos": "informacion",
            "contacto": "contacto", "contactar": "contacto", "localizar": "contacto", "encontrar": "buscar", "busqueda": "buscar", "b√∫squeda": "buscar",
            
            // Correcciones de t√©rminos de comunicaci√≥n
            "hola": "hola", "holi": "hola", "holis": "hola", "buenos dias": "hola", "buenos d√≠as": "hola", 
            "buenas tardes": "hola", "buenas noches": "hola", "saludos": "hola", "saludo": "hola", "hey": "hola",
            "adios": "adios", "adi√≥s": "adios", "hasta luego": "adios", "hasta pronto": "adios", "nos vemos": "adios", "chao": "adios", "bye": "adios",
            "gracias": "gracias", "gracia": "gracias", "grasias": "gracias", "muchas gracias": "gracias", "mil gracias": "gracias",
            "por favor": "por favor", "porfavor": "por favor", "porfa": "por favor", "porfi": "por favor", "haz el favor": "por favor",
            "ok": "ok", "okey": "ok", "okey": "ok", "okis": "ok", "vale": "ok", "va": "ok", "listo": "ok", "de acuerdo": "ok", "esta bien": "ok",
            "si": "si", "s√≠": "si", "sip": "si", "afirmativo": "si", "claro": "si", "por supuesto": "si", "desde luego": "si",
            "no": "no", "nop": "no", "nones": "no", "para nada": "no", "ni hablar": "no", "de ninguna manera": "no", "jam√°s": "no", "nunca": "no",
            "ayuda": "ayuda", "soporte": "ayuda", "asistencia": "ayuda", "auxilio": "ayuda", "socorro": "ayuda",
            
            // Nombres propios comunes mal escritos
            "ivan de la paz": "ivan de la paz notario",
            "javier gambin": "javier gambin ortu√±o",
            "juan jose recio": "juan jose recio lanchas",
            "silvia garcia": "silvia garcia maroto",
            "manuel garcia": "manuel garcia diaz",
            "jesus fernandez": "jesus fernandez aviles",
            
            // T√©rminos t√©cnicos espec√≠ficos
            "telemando": "operador tme",
            "operador telemando": "operador tme",
            "tme": "operador tme",
            "operador tme": "operador tme",
            "operador de telemando": "operador tme",
            "operadora tme": "operador tme",
            "operadora de telemando": "operador tme",
            "operador de tele mando": "operador tme",
            "operador tele mando": "operador tme"
        };

        const SIMULATED_SYNONYMS_JSON = { 
            telefono: ["tel√©fono", "telefono", "contacto", "llamar", "numero", "m√≥vil", "movil", "phone", "celular", "fono", "num"],
            correo: ["correo", "email", "e-mail", "direccion de correo", "direcci√≥n de correo", "contactar por email", "mail"],
            puesto: ["puesto", "cargo", "rol", "funcion", "funci√≥n", "ocupacion", "ocupaci√≥n", "que hace", "qu√© hace", "a que se dedica", "a qu√© se dedica", "trabajo de", "labor", "responsabilidad de", "cometido", "posicion", "posici√≥n"],
            ubicacion: ["ubicaci√≥n", "ubicacion", "centro", "lugar", "donde esta", "d√≥nde est√°", "donde trabaja", "d√≥nde trabaja", "localizacion", "localizaci√≥n", "sede", "emplazamiento", "sitio", "localidad", "base", "estacion"],
            quien_es: ["qui√©n es", "quien es", "info de", "informacion sobre", "dame datos de", "datos sobre", "cuentame de", "cu√©ntame de", "detalles de", "saber de", "quien se encarga de"],
            personas_en_loc: ["personas", "personal", "equipo", "gente", "trabajadores", "quienes trabajan", "qui√©nes trabajan", "cuantos hay", "cu√°ntos hay", "listado de personal", "plantilla", "nomina de", "quien esta en", "qui√©n est√° en", "empleados en", "miembros en", "trabaja en", "cuanta gente hay en"],
            ambito: ["√°mbito", "ambito", "mantenimiento de", "cubre", "alcance", "responsable de linea", "l√≠neas que cubre", "lineas que cubre", "tramo", "se encarga de", "competencia de", "area de mantenimiento", "√°rea de mantenimiento"],
            direccion_loc: ["direcci√≥n", "direccion", "como llego", "c√≥mo llego", "como ir", "c√≥mo ir", "ubicacion fisica", "ubicaci√≥n f√≠sica", "donde se encuentra", "d√≥nde se encuentra", "mapa de", "localizar", "ir a"],
            lista: ["lista de", "listado de", "dime los", "dime todos", "cuales son", "cu√°les son", "muestrame", "mu√©strame", "todos los", "todas las", "listar", "enumerar", "dame una lista", "ver todos"],
            saludo: ["hola", "buenos dias", "buenos d√≠as", "buenas tardes", "buenas noches", "hey", "que tal", "qu√© tal", "buenas", "saludos", "que pasa", "qu√© pasa", "epa"],
            despedida: ["adios", "adi√≥s", "hasta luego", "chao", "nos vemos", "bye", "hasta pronto", "finalizar", "terminar", "me voy"],
            agradecimiento: ["gracias", "muchas gracias", "agradecido", "muy amable", "ok gracias", "vale gracias", "perfecto gracias", "genial gracias", "te lo agradezco", "excelente", "gracias!"],
            ayuda_cmd: ["ayuda", "comandos", "que puedes hacer", "qu√© puedes hacer", "opciones", "info", "informacion", "help", "manual", "instrucciones", "como funciona", "c√≥mo funciona"],
            y_su: ["y su", "y el de el", "y la de el", "y el de ella", "y la de ella", "tambien su", "tambi√©n su", "dime tambien", "dime tambi√©n", "necesito tambien", "necesito tambi√©n", "adem√°s su", "ademas su", "y el suyo", "y la suya", "dame tambi√©n su"],
            solo_eso: ["solo eso", "nada mas", "nada m√°s", "eso es todo", "listo", "ok", "vale", "ya esta", "ya est√°", "perfecto"],
            comparar_mas: ["mas", "m√°s", "mayor numero", "mayor n√∫mero", "quien tiene mas", "qui√©n tiene m√°s", "donde hay mas", "d√≥nde hay m√°s", "cual tiene mas", "cu√°l tiene m√°s", "que tiene mas", "qu√© tiene m√°s"],
            comparar_o: [" o ", " √≥ ", " versus ", " vs "]
        };

        const typingIndicatorElement = document.createElement('div'); 
        typingIndicatorElement.classList.add('typing-indicator');
        typingIndicatorElement.innerHTML = '<span></span><span></span><span></span>';
        let isTyping = false;
        let dataLoaded = false;

        async function loadExternalConfigs() {
            CONFIG_TYPO_CORRECTIONS = SIMULATED_TYPOS_JSON;
            CONFIG_INTENT_SYNONYMS = SIMULATED_SYNONYMS_JSON;
        }

        async function loadData() {
            appendMessage('bot', 'Cargando datos y configuraciones, por favor espera...');
            try {
                await loadExternalConfigs();
                const response = await fetch('./unified_data.json');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status} al cargar unified_data.json`);
                unifiedData = await response.json();
                
                allPersons = [];
                allLocations = [];
                unifiedData.forEach(centro => {
                    allLocations.push({ ...centro, personas: undefined });
                    if (centro.personas) {
                        centro.personas.forEach(persona => {
                            allPersons.push({ ...persona, ubicacion: centro.nombre_centro });
                        });
                    }
                });

                buildEntityIndex();
                dataLoaded = true;
                chatBox.innerHTML = '';
                appendMessage('bot', INITIAL_BOT_MESSAGE);
                userInput.disabled = false;
                sendButton.disabled = false;
                userInput.placeholder = "Escribe tu pregunta aqu√≠...";
                userInput.focus();

            } catch (error) {
                console.error("Error cr√≠tico durante la carga:", error);
                appendMessage('bot', `Error cr√≠tico al cargar: ${error.message}. Por favor, revisa la consola.`);
                userInput.placeholder = "Error al cargar datos.";
            }
        }
        
        function normalize(text, preserveSpecialChars = false) {
            if (!text || typeof text !== 'string') return '';
            
            // Convertir a min√∫sculas y normalizar caracteres especiales
            let normalized = text.toLowerCase().trim();
            
            // Normalizar caracteres acentuados y diacr√≠ticos
            normalized = normalized.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
            
            // Aplicar correcciones de errores tipogr√°ficos
            for (const typo in CONFIG_TYPO_CORRECTIONS) {
                const correction = CONFIG_TYPO_CORRECTIONS[typo];
                // Escapar caracteres especiales en la expresi√≥n regular
                const escapedTypo = typo.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                // Usar l√≠mites de palabra completos para evitar coincidencias parciales no deseadas
                const regex = new RegExp(`(^|\\s)${escapedTypo}(\\s|$)`, 'gi');
                normalized = normalized.replace(regex, `$1${correction}$2`);
                
                // Manejar el caso cuando el typo est√° al principio o final del texto
                if (normalized === typo) {
                    normalized = correction;
                } else if (normalized.startsWith(typo + ' ')) {
                    normalized = normalized.replace(typo, correction);
                } else if (normalized.endsWith(' ' + typo)) {
                    normalized = normalized.replace(typo, correction);
                }
            }
            
            // Manejar n√∫meros de tel√©fono y extensiones
            normalized = normalized.replace(/\b(\d{3})[-\.\s]?(\d{2})[-\.\s]?(\d{2})[-\.\s]?(\d{2})\b/g, '$1$2$3$4');
            normalized = normalized.replace(/\bext\.?\s*\b(\d+)\b/gi, 'extension $1');
            
            // Manejar espacios m√∫ltiples y limpieza final
            normalized = normalized.replace(/\s+/g, ' ').trim();
            
            // Eliminar caracteres especiales si no se deben preservar
            if (!preserveSpecialChars) {
                // Mantener solo letras, n√∫meros y espacios
                normalized = normalized.replace(/[^a-z0-9\s]/gi, '');
            }
            
            return normalized;
        }

        function buildEntityIndex() {
            entityIndex.clear();
            const addEntity = (key, data, type, originalKey, relevanceScore = 1.0) => {
                const normalizedKey = normalize(key, type.startsWith('puesto_') || type.startsWith('person_') || type.startsWith('location_')); 
                if (!normalizedKey) return;

                if (!entityIndex.has(normalizedKey)) {
                    entityIndex.set(normalizedKey, []);
                }
                if (!entityIndex.get(normalizedKey).some(e => e.type === type && JSON.stringify(e.data) === JSON.stringify(data))) {
                     entityIndex.get(normalizedKey).push({ data, type, originalKey: originalKey || key, relevance: relevanceScore });
                }
            };

            allPersons.forEach(person => {
                if (person.nombre && person.nombre.toLowerCase() !== PENDING_NOM_LOWER) {
                    addEntity(person.nombre, person, 'person_full', person.nombre, 1.0);
                    const nameParts = person.nombre.split(' ');
                    if (nameParts.length > 1) {
                        addEntity(nameParts[0], person, 'person_firstname', person.nombre, 0.6); 
                        
                        const lastNamesString = nameParts.slice(1).join(' ');
                        if (lastNamesString) {
                            addEntity(lastNamesString, person, 'person_all_lastnames', person.nombre, 0.75);
                        }

                        if (nameParts.length >= 2) { // Nombre + Primer Apellido
                             addEntity(`${nameParts[0]} ${nameParts[1]}`, person, 'person_name_firstlastname', person.nombre, 0.9);
                        }
                        
                        if (nameParts.length >= 2) { // Primer apellido solo
                            let firstLastName = nameParts[1];
                            let isCompoundLastNameStart = false;
                            if ((firstLastName.toLowerCase() === 'de' || firstLastName.toLowerCase() === 'del' || firstLastName.toLowerCase() === 'la') && nameParts.length > 2) {
                                firstLastName = nameParts[2]; 
                                addEntity(`${nameParts[1]} ${nameParts[2]}`, person, 'person_first_compound_lastname_part', person.nombre, 0.72); // "De Paz"
                                isCompoundLastNameStart = true;
                            }
                            addEntity(firstLastName, person, 'person_first_lastname_alone', person.nombre, 0.7);
                             // Nombre + primer apellido (considerando compuestos "De La")
                            if(isCompoundLastNameStart && nameParts.length > 2) {
                                addEntity(`${nameParts[0]} ${nameParts[1]} ${nameParts[2]}`, person, 'person_name_first_compound_lastname', person.nombre, 0.92);
                            }
                        }


                        if (nameParts.length >= 3) { // Nombre + Primer Apellido + Segundo Apellido (si existe)
                             addEntity(`${nameParts[0]} ${nameParts[1]} ${nameParts[2]}`, person, 'person_name_two_lastnames', person.nombre, 0.95);
                        }
                         if (nameParts.length > 2 && nameParts[nameParts.length -1]) { // √öltimo apellido solo (si hay m√°s de un apellido)
                            addEntity(nameParts[nameParts.length -1], person, 'person_last_lastname_alone', person.nombre, 0.68);
                        }
                    }
                }
                 if (person.puesto && person.puesto.toLowerCase() !== PENDING_NOM_LOWER) {
                    addEntity(person.puesto, {nombre_puesto: person.puesto, original_persona_puesto: person.puesto}, 'puesto_general', person.puesto, 0.9); 
                    if (person.puesto.toLowerCase().includes("jefe de base")) addEntity("jefe de base", {nombre_puesto: "Jefe de Base", original_persona_puesto: person.puesto}, 'puesto_variant', person.puesto, 0.8);
                    if (person.puesto.toLowerCase().includes("tecnico de infra y via")) addEntity("tecnico de via", {nombre_puesto: "T√©cnico De Infra y V√≠a", original_persona_puesto: person.puesto}, 'puesto_variant', person.puesto, 0.8);
                    if (person.puesto.toLowerCase().includes("c.t. ingenieria civil")) addEntity("ct ingenieria civil", {nombre_puesto: "C.T. Ingenier√≠a Civil", original_persona_puesto: person.puesto}, 'puesto_variant', person.puesto, 0.8);
                    if (person.puesto.toLowerCase().startsWith("tecnico ")) addEntity("tecnico", {nombre_puesto: "T√©cnico", original_persona_puesto: person.puesto}, 'puesto_generic_term', person.puesto, 0.5);
                    if (person.puesto.toLowerCase().startsWith("operador ")) addEntity("operador", {nombre_puesto: "Operador", original_persona_puesto: person.puesto}, 'puesto_generic_term', person.puesto, 0.5);
                    if (person.puesto.toLowerCase() === "operador tme") addEntity("telemando", {nombre_puesto: "Operador TME", original_persona_puesto: person.puesto}, 'puesto_alias', person.puesto, 0.85);

                }
                if (person.telefono && person.telefono !== PENDING_NOM_LOWER) {
                    const phoneDigits = person.telefono.replace(/\D/g, '');
                    addEntity(phoneDigits, person, 'person_phone', person.nombre, 0.99); // Muy alta relevancia
                    addEntity(person.telefono, person, 'person_phone_formatted', person.nombre, 0.98);
                }
            });

            allLocations.forEach(location => {
                addEntity(location.nombre_centro, location, 'location_full', location.nombre_centro, 1.0);
                if (location.nombre_centro.toLowerCase().startsWith("bm ")) addEntity(location.nombre_centro.substring(3), location, 'location_shortname', location.nombre_centro, 0.8);
                if (location.nombre_centro.toLowerCase().startsWith("et ")) addEntity(location.nombre_centro.substring(3), location, 'location_shortname', location.nombre_centro, 0.8);
                if (location.nombre_centro.toLowerCase().startsWith("crc ")) addEntity(location.nombre_centro.substring(4), location, 'location_shortname', location.nombre_centro, 0.8);

                const keywords = location.nombre_centro.split(/[\s-]+/).filter(kw => kw.length > 2 && !["de", "la", "el", "los", "las", "paseo"].includes(kw.toLowerCase()));
                keywords.forEach(kw => addEntity(kw, location, 'location_keyword', location.nombre_centro, 0.6));
            });
            
            addEntity(PENDING_NOM_LOWER, { nombre: PENDING_NOM_LOWER, puesto: PENDING_NOM_LOWER }, 'person_pending', PENDING_NOM_LOWER, 0.9);

            const explicitPuestos = ["jefe de area", "jefe de base", "coordinador de linea", "secretaria", "tecnico ii.ss.", "tecnico iiss", "tecnico de infra y via", "tecnico infra via", "tecnico energia", "tecnico de energia", "tecnico telecomunicaciones", "ct ingenieria civil", "ct ingenier√≠a civil", "tecnico", "operador", "gtm", "operador csi", "operador tme", "jefe de unidad", "tecnico documentalista", "tecnico de inversiones", "tecnico proyectos y explanaciones", "tecnico de proteccion civil", "tecnico analisis incidencias"];
            explicitPuestos.forEach(puesto => {
                 addEntity(puesto, { nombre_puesto: puesto }, 'puesto_explicit', puesto, 0.95);
            });
        }
        
        // Lista de palabras comunes a ignorar en las b√∫squedas
        const COMMON_WORDS = new Set(['de', 'del', 'la', 'el', 'los', 'las', 'y', 'e', 'o', 'u', 'a', 'en', 'con', 'por', 'para', 'al', 'se', 'su', 'sus', 'un', 'una', 'unos', 'unas']);
        
        function findEntities(normalizedInput) {
            let foundEntities = [];
            // Filtrar palabras comunes
            const inputWords = normalizedInput
                .split(' ')
                .filter(w => w.length > 0 && !COMMON_WORDS.has(w.toLowerCase()));

            for (let len = Math.min(inputWords.length, 7); len >= 1; len--) {
                for (let i = 0; i <= inputWords.length - len; i++) {
                    const phrase = inputWords.slice(i, i + len).join(' ');
                    const normalizedPhrase = normalize(phrase, true);
                    
                    // Si la frase est√° vac√≠a despu√©s de normalizar, saltar
                    if (!normalizedPhrase) continue;

                    if (entityIndex.has(normalizedPhrase)) {
                        entityIndex.get(normalizedPhrase).forEach(entity => {
                            const existingIndex = foundEntities.findIndex(fe => JSON.stringify(fe.data) === JSON.stringify(entity.data));
                            if (existingIndex !== -1) {
                                if (len > foundEntities[existingIndex].length || 
                                   (len === foundEntities[existingIndex].length && entity.type.includes('_full') && !foundEntities[existingIndex].type.includes('_full')) ||
                                   (len === foundEntities[existingIndex].length && entity.relevance > foundEntities[existingIndex].relevance) ||
                                   (len === foundEntities[existingIndex].length && entity.type === 'person_phone' && foundEntities[existingIndex].type !== 'person_phone') // Priorizar phone match
                                ) {
                                    foundEntities.splice(existingIndex, 1, { ...entity, matchedKey: normalizedPhrase, matchType: 'exact_phrase', length: len });
                                }
                            } else {
                                 foundEntities.push({ ...entity, matchedKey: normalizedPhrase, matchType: 'exact_phrase', length: len });
                            }
                        });
                    }
                }
            }
            
            if (normalizedInput.includes(PENDING_NOM_LOWER)) {
                 const pteEntityArray = entityIndex.get(PENDING_NOM_LOWER);
                if (pteEntityArray && pteEntityArray.length > 0) {
                    const pteEntity = pteEntityArray[0];
                     if (!foundEntities.some(fe => fe.type === 'person_pending')) {
                        foundEntities.push({ ...pteEntity, matchedKey: PENDING_NOM_LOWER, matchType: 'exact_phrase', length: PENDING_NOM_LOWER.split(' ').length });
                    }
                }
            }
            
            foundEntities.sort((a, b) => {
                 const typePriority = (type) => {
                    if (type === 'person_phone') return -2; // M√°xima prioridad si es un match de tel√©fono exacto
                    if (type === 'person_phone_formatted') return -1;
                    if (type === 'person_full') return 0;
                    if (type === 'person_name_two_lastnames') return 1;
                    if (type === 'person_name_first_compound_lastname') return 1; 
                    if (type === 'person_name_firstlastname') return 2;
                    if (type === 'person_all_lastnames') return 3;
                    if (type === 'person_first_lastname_alone') return 4;
                    if (type === 'person_last_lastname_alone') return 4;
                    if (type === 'person_firstname') return 5;
                    if (type.startsWith('location_full')) return 0;
                    if (type.startsWith('puesto_explicit') || type.startsWith('puesto_general') || type.startsWith('puesto_alias')) return 1; 
                    return 6;
                };

                if (typePriority(a.type) !== typePriority(b.type)) { // Primero por tipo super prioritario
                    return typePriority(a.type) - typePriority(b.type);
                }
                if (a.length !== b.length) return b.length - a.length; // Luego por longitud del match
                
                return (b.relevance || 0) - (a.relevance || 0); // Finalmente por relevancia del √≠ndice
            });
            
            const uniqueEntitiesFinal = [];
            const seenData = new Set();
            for (const entity of foundEntities) {
                const dataSignature = JSON.stringify(entity.data);
                if (!seenData.has(dataSignature)) {
                    uniqueEntitiesFinal.push(entity);
                    seenData.add(dataSignature);
                }
            }
            return uniqueEntitiesFinal;
        }

        function checkKeywords(normalizedInput, intentKey, exact = false) {
            if (!CONFIG_INTENT_SYNONYMS[intentKey]) return false;
            const keywords = CONFIG_INTENT_SYNONYMS[intentKey];
            const normalizedInputForCheck = normalize(normalizedInput); 

            if (exact) { 
                return keywords.some(kw => normalize(kw) === normalizedInputForCheck);
            }
            return keywords.some(kw => normalizedInputForCheck.includes(normalize(kw)));
        }

        let intentionRules = [];

        function defineIntentionRules() {
            intentionRules = [
                 // Nueva Regla: B√∫squeda por Tel√©fono (ALTA PRIORIDAD)
                {
                    name: "find_person_by_phone",
                    condition: (ni, ent, ctx, originalInput) => {
                        const phoneQuery = (originalInput || ni).replace(/\s+/g, ''); // Usar originalInput para preservar formato si es posible
                        return /^\+?\d{9,15}$/.test(phoneQuery) && ent.some(e => e.type === 'person_phone' && e.data.telefono.replace(/\D/g,'') === phoneQuery.replace(/\D/g,''));
                    },
                    action: (ni, ent, ctx, originalInput) => {
                        const phoneQuery = (originalInput || ni).replace(/\D/g, '');
                        const personEntity = ent.find(e => e.type === 'person_phone' && e.data.telefono.replace(/\D/g,'') === phoneQuery);
                        if (personEntity) {
                            conversationContext.lastPerson = personEntity.data;
                            conversationContext.lastLocation = null; conversationContext.lastPuesto = null;
                            return `El n√∫mero de tel√©fono **${personEntity.data.telefono}** pertenece a ${formatPersonInfo(personEntity.data)}`;
                        }
                        return "No encontr√© a nadie con ese n√∫mero de tel√©fono.";
                    }
                },
                // Reglas de Contexto ("y su...")
                {
                    name: "context_person_telefono",
                    condition: (ni, ent, ctx) => ctx.lastPerson && checkKeywords(ni, 'y_su') && checkKeywords(ni, 'telefono'),
                    action: (ni, ent, ctx) => { conversationContext.lastLocation = null; conversationContext.lastPuesto = null; return formatPersonInfo(ctx.lastPerson, 'telefono');}
                },
                {
                    name: "context_person_correo",
                    condition: (ni, ent, ctx) => ctx.lastPerson && checkKeywords(ni, 'y_su') && checkKeywords(ni, 'correo'),
                    action: (ni, ent, ctx) => { conversationContext.lastLocation = null; conversationContext.lastPuesto = null; return formatPersonInfo(ctx.lastPerson, 'correo');}
                },
                {
                    name: "context_person_puesto",
                    condition: (ni, ent, ctx) => ctx.lastPerson && checkKeywords(ni, 'y_su') && checkKeywords(ni, 'puesto'),
                    action: (ni, ent, ctx) => { conversationContext.lastLocation = null; conversationContext.lastPuesto = null; return formatPersonInfo(ctx.lastPerson, 'puesto');}
                },
                {
                    name: "context_person_ubicacion",
                    condition: (ni, ent, ctx) => ctx.lastPerson && checkKeywords(ni, 'y_su') && checkKeywords(ni, 'ubicacion'),
                    action: (ni, ent, ctx) => { conversationContext.lastLocation = null; conversationContext.lastPuesto = null; return formatPersonInfo(ctx.lastPerson, 'ubicacion');}
                },
                {
                    name: "context_location_ambitos",
                    condition: (ni, ent, ctx) => ctx.lastLocation && checkKeywords(ni, 'y_su') && checkKeywords(ni, 'ambito'),
                    action: (ni, ent, ctx) => { conversationContext.lastPerson = null; conversationContext.lastPuesto = null; return formatLocationInfo(ctx.lastLocation, 'ambitos');}
                },
                {
                    name: "context_location_persons",
                    condition: (ni, ent, ctx) => ctx.lastLocation && checkKeywords(ni, 'y_su') && checkKeywords(ni, 'personas_en_loc'),
                    action: (ni, ent, ctx) => { conversationContext.lastPerson = null; conversationContext.lastPuesto = null; return formatLocationInfo(ctx.lastLocation, 'personas');}
                },
                {
                    name: "context_location_details",
                    condition: (ni, ent, ctx) => ctx.lastLocation && checkKeywords(ni, 'y_su') && checkKeywords(ni, 'direccion_loc'),
                    action: (ni, ent, ctx) => { conversationContext.lastPerson = null; conversationContext.lastPuesto = null; return formatLocationInfo(ctx.lastLocation, 'direccion');}
                },
                {
                    name: "context_puesto_persons",
                    condition: (ni, ent, ctx) => ctx.lastPuesto && checkKeywords(ni, 'y_su') && checkKeywords(ni, 'personas_en_loc'),
                    action: (ni, ent, ctx) => {
                        conversationContext.lastPerson = null; conversationContext.lastLocation = null;
                        const pEntities = findEntities(normalize(ctx.lastPuesto.nombre_puesto, true));
                        return getIntentResponse(ni, pEntities, 'find_person_by_role');
                    }
                },
                {
                    name: "context_acknowledged",
                    condition: (ni, ent, ctx) => (ctx.lastPerson || ctx.lastLocation || ctx.lastPuesto) && checkKeywords(ni, 'solo_eso', true),
                    action: (ni, ent, ctx) => { conversationContext.clear(); return "Entendido."; }
                },

                // Comandos directos
                {
                    name: "ayuda",
                    condition: (ni) => checkKeywords(ni, 'ayuda_cmd', true) || ni === 'ayuda',
                    action: () => { displayHelpBubbles(); return 'Puedo ayudarte con informaci√≥n sobre personal, centros y listados. Aqu√≠ tienes ejemplos:'; }
                },
                { name: "saludo", condition: (ni) => checkKeywords(ni, 'saludo'), action: () => CONFIG_INTENT_SYNONYMS.saludo[Math.floor(Math.random() * CONFIG_INTENT_SYNONYMS.saludo.length)] + "! ¬øEn qu√© puedo ayudarte?" },
                { name: "despedida", condition: (ni) => checkKeywords(ni, 'despedida'), action: () => CONFIG_INTENT_SYNONYMS.despedida[Math.floor(Math.random() * CONFIG_INTENT_SYNONYMS.despedida.length)] + "! Que tengas un buen d√≠a." },
                { name: "agradecimiento", condition: (ni) => checkKeywords(ni, 'agradecimiento'), action: () => "De nada. ¬°Ha sido un placer ayudarte!" },
                
                 // Regla unificada para persona con manejo de apellido
                {
                    name: "get_person_specific_info_or_full",
                    condition: (ni, ent) => {
                        const persons = ent.filter(e => e.type.startsWith('person_') && e.type !== 'person_pending');
                        if (persons.length !== 1) return false; 
                        
                        const personEntity = persons[0];
                        const personData = personEntity.data;
                        const normPersonNameFull = normalize(personData.nombre, true);
                        const inputWordsCount = ni.split(' ').length;

                        // La entrada es un match fuerte del nombre o "qui√©n es [nombre]"
                        const isStrongNameQuery = (personEntity.matchedKey === ni && personEntity.length >= Math.max(2, inputWordsCount)) ||
                                                  (normPersonNameFull.startsWith(ni) && personEntity.length >= inputWordsCount && inputWordsCount >= 2) ||
                                                  (personEntity.type === 'person_full' && ni === personEntity.matchedKey) ||
                                                  (checkKeywords(ni, 'quien_es') && (personEntity.matchedKey === ni.replace("quien es","").trim() || normPersonNameFull.includes(ni.replace("quien es","").trim()) ) );

                        // Si es un match fuerte del nombre, y se pide info espec√≠fica o es solo el nombre/quien es.
                        if (isStrongNameQuery) {
                            if (checkKeywords(ni, 'telefono') || checkKeywords(ni, 'correo') || 
                                checkKeywords(ni, 'puesto') || checkKeywords(ni, 'ubicacion') ||
                                checkKeywords(ni, 'quien_es') || ni === personEntity.matchedKey || normPersonNameFull.startsWith(ni)) {
                                return true;
                            }
                        }
                        
                        // Caso: "ubicaci√≥n [Nombre Apellido]" o similar
                        const specificInfoKeywords = ['ubicacion', 'telefono', 'correo', 'puesto'];
                        const requestedSpecificInfo = specificInfoKeywords.find(kw => checkKeywords(ni, kw));
                        if (requestedSpecificInfo) {
                            // Extraer el nombre de la query sin la keyword de info espec√≠fica
                            let nameQueryPart = ni;
                            CONFIG_INTENT_SYNONYMS[requestedSpecificInfo].forEach(syn => {
                                nameQueryPart = nameQueryPart.replace(new RegExp(syn, 'gi'), '');
                            });
                            nameQueryPart = normalize(nameQueryPart.replace(/\bde\b/gi, '').trim(), true); // quitar "de" y normalizar
                            
                            // Si la parte del nombre de la query est√° contenida en el matchedKey de la persona
                            // Y el matchedKey es suficientemente espec√≠fico
                            if (personEntity.matchedKey.includes(nameQueryPart) && personEntity.length >= nameQueryPart.split(' ').length && personEntity.length >=2) {
                                return true;
                            }
                        }
                        return false;
                    },
                    action: (ni, ent) => { 
                        const person = ent.find(e => e.type.startsWith('person_')).data;
                        conversationContext.lastPerson = person;
                        conversationContext.lastLocation = null; conversationContext.lastPuesto = null;

                        if (checkKeywords(ni, 'telefono')) return formatPersonInfo(person, 'telefono');
                        if (checkKeywords(ni, 'correo')) return formatPersonInfo(person, 'correo');
                        if (checkKeywords(ni, 'puesto')) return formatPersonInfo(person, 'puesto');
                        if (checkKeywords(ni, 'ubicacion')) return formatPersonInfo(person, 'ubicacion');
                        return formatPersonInfo(person, 'full');
                    }
                },
                // Reglas de ubicaci√≥n
                {
                    name: "get_location_specific_or_full", // Regla unificada para ubicaci√≥n
                    condition: (ni, ent) => {
                        const locations = ent.filter(e => e.type.startsWith('location_'));
                        if (locations.length !== 1) return false;
                        const locEntity = locations[0];

                        // Verificar si hay una palabra clave de informaci√≥n espec√≠fica
                        const specificInfoKeywords = ['ambito', 'direccion_loc', 'personas_en_loc'];
                        const hasInfoKeyword = specificInfoKeywords.some(kw => checkKeywords(ni, kw));
                        
                        // Extraer la parte del nombre de la ubicaci√≥n
                        let locationNamePart = ni;
                        if (hasInfoKeyword) {
                            // Eliminar las palabras clave de informaci√≥n para obtener solo el nombre
                            specificInfoKeywords.forEach(kw => {
                                CONFIG_INTENT_SYNONYMS[kw]?.forEach(syn => {
                                    locationNamePart = locationNamePart.replace(new RegExp(syn, 'gi'), '');
                                });
                            });
                            locationNamePart = locationNamePart.replace(/\bde\b/gi, '').trim();
                        }
                        
                        // Normalizar para comparaci√≥n
                        const normalizedLocationName = normalize(locationNamePart, true);
                        const normalizedEntityName = normalize(locEntity.matchedKey, true);
                        
                        // Verificar si el nombre de la ubicaci√≥n est√° contenido en la consulta
                        const locationNameInQuery = normalizedEntityName.split(' ').every(part => 
                            normalizedLocationName.includes(part)
                        );
                        
                        // Si hay una palabra clave de informaci√≥n y el nombre de la ubicaci√≥n coincide
                        if (hasInfoKeyword && locationNameInQuery) {
                            return true;
                        }
                        
                        // Si es una coincidencia exacta o comienza con el nombre de la ubicaci√≥n
                        const isStrongLocationQuery = (normalizedEntityName === normalizedLocationName ||
                                                     normalizedEntityName.startsWith(normalizedLocationName)) &&
                                                    locEntity.length >= normalizedLocationName.split(' ').length;
                        
                        return isStrongLocationQuery;
                    },
                    action: (ni, ent) => {
                        const location = ent.find(e => e.type.startsWith('location_')).data;
                        conversationContext.lastLocation = location; conversationContext.lastPerson = null; conversationContext.lastPuesto = null;
                        if (checkKeywords(ni, 'ambito')) return formatLocationInfo(location, 'ambitos');
                        if (checkKeywords(ni, 'direccion_loc')) return formatLocationInfo(location, 'direccion');
                        if (checkKeywords(ni, 'personas_en_loc')) return formatLocationInfo(location, 'personas');
                        return formatLocationInfo(location, 'full');
                    }
                },
                { 
                    name: "find_person_by_role_direct",
                    condition: (ni, ent) => {
                        const puestos = ent.filter(e => e.type.startsWith('puesto_') || e.type.startsWith('puesto_alias'));
                        return puestos.length > 0 && 
                               (checkKeywords(ni, 'quien_es') || checkKeywords(ni, 'lista') || 
                                (ent.filter(e => e.type.startsWith('person_')).length === 0 && ent.filter(e => e.type.startsWith('location_')).length === 0)
                               );
                    },
                    action: (ni, ent, ctx, originalInput) => {
                        conversationContext.clear(); 
                        const puestoData = ent.find(e => e.type.startsWith('puesto_') || e.type.startsWith('puesto_alias'));
                        if(puestoData) conversationContext.lastPuesto = puestoData.data;
                        return getIntentResponse(ni, ent, 'find_person_by_role', originalInput);
                    }
                },
                // Nuevas reglas de comparaci√≥n
                {
                    name: "compare_puesto_personnel_count",
                    condition: (ni, ent) => {
                        const puestos = ent.filter(e => e.type.startsWith('puesto_') || e.type.startsWith('puesto_alias'));
                        return (ni.includes(" o ") || ni.includes(" √≥ ") || ni.includes(" versus ") || ni.includes(" vs ")) && 
                               checkKeywords(ni, 'comparar_mas') &&
                               puestos.length >= 2 &&
                               new Set(puestos.map(p => p.data.nombre_puesto || p.originalKey)).size >= 2;
                    },
                    action: (ni, ent) => { /* ... (c√≥digo de la acci√≥n ya proporcionado anteriormente) ... */
                        const puestos = ent.filter(e => e.type.startsWith('puesto_') || e.type.startsWith('puesto_alias'));
                        const uniquePuestosData = [];
                        const seenPuestos = new Set();
                        for (const pEntity of puestos) {
                            const pName = pEntity.data.nombre_puesto || pEntity.originalKey;
                            if (!seenPuestos.has(pName)) {
                                uniquePuestosData.push(pEntity.data);
                                seenPuestos.add(pName);
                            }
                            if (uniquePuestosData.length === 2) break;
                        }

                        if (uniquePuestosData.length < 2) return "Necesito al menos dos puestos diferentes para comparar.";

                        const puesto1Data = uniquePuestosData[0];
                        const puesto2Data = uniquePuestosData[1];

                        const normPuesto1 = normalize(puesto1Data.nombre_puesto || puesto1Data.originalKey, true);
                        const normPuesto2 = normalize(puesto2Data.nombre_puesto || puesto2Data.originalKey, true);

                        const count1 = allPersons.filter(p => p.puesto && normalize(p.puesto, true).includes(normPuesto1) && p.nombre.toLowerCase() !== PENDING_NOM_LOWER).length;
                        const count2 = allPersons.filter(p => p.puesto && normalize(p.puesto, true).includes(normPuesto2) && p.nombre.toLowerCase() !== PENDING_NOM_LOWER).length;
                        
                        const displayPuesto1 = puesto1Data.nombre_puesto || puesto1Data.originalKey;
                        const displayPuesto2 = puesto2Data.nombre_puesto || puesto2Data.originalKey;

                        if (count1 > count2) return `Hay m√°s personal con el puesto **${displayPuesto1}** (${count1}) que **${displayPuesto2}** (${count2}).`;
                        if (count2 > count1) return `Hay m√°s personal con el puesto **${displayPuesto2}** (${count2}) que **${displayPuesto1}** (${count1}).`;
                        if (count1 === 0 && count2 === 0) return `No encontr√© personal asignado ni para **${displayPuesto1}** ni para **${displayPuesto2}**.`;
                        return `Hay la misma cantidad de personal para **${displayPuesto1}** (${count1}) y **${displayPuesto2}** (${count2}).`;
                    }
                },
                {
                    name: "compare_location_personnel_count",
                    condition: (ni, ent) => {
                        return checkKeywords(ni, 'comparar_mas') && 
                               (ni.includes("base") || ni.includes("centro") || ni.includes("ubicacion")) &&
                               checkKeywords(ni, 'personas_en_loc');
                    },
                    action: (ni, ent) => { /* ... (c√≥digo de la acci√≥n ya proporcionado anteriormente) ... */
                        if (allLocations.length === 0) return "No tengo datos de ubicaciones para comparar.";
                        let maxPersonnel = -1;
                        let locationsWithMax = [];
                        allLocations.forEach(loc => {
                            const personnelCount = allPersons.filter(p => p.ubicacion === loc.nombre_centro && p.nombre.toLowerCase() !== PENDING_NOM_LOWER).length;
                            if (personnelCount > maxPersonnel) {
                                maxPersonnel = personnelCount;
                                locationsWithMax = [loc.nombre_centro];
                            } else if (personnelCount === maxPersonnel && personnelCount > 0) {
                                locationsWithMax.push(loc.nombre_centro);
                            }
                        });
                        if (maxPersonnel <= 0 || locationsWithMax.length === 0) return "No pude determinar qu√© ubicaci√≥n tiene m√°s personal o ninguna tiene personal asignado.";
                        if (locationsWithMax.length === 1) return `La ubicaci√≥n con m√°s personal asignado es **${locationsWithMax[0]}** (con ${maxPersonnel} persona${maxPersonnel > 1 ? 's' : ''}).`;
                        return `Las ubicaciones con m√°s personal asignado (con ${maxPersonnel} persona${maxPersonnel > 1 ? 's' : ''} cada una) son: **${locationsWithMax.join(', ')}**.`;
                    }
                },
                // Nueva Regla: Lista de Todos los Puestos
                {
                    name: "list_all_puestos",
                    condition: (ni, ent) => {
                        return checkKeywords(ni, 'lista') && 
                               (ni.includes("puesto") || ni.includes("cargo") || ni.includes("rol")) &&
                               ent.filter(e => e.type.startsWith('puesto_')).length === 0;
                    },
                    action: (ni, ent) => { /* ... (c√≥digo de la acci√≥n ya proporcionado anteriormente) ... */
                        const puestoCounts = new Map();
                        allPersons
                            .filter(p => p.puesto && p.puesto.toLowerCase() !== PENDING_NOM_LOWER && p.nombre.toLowerCase() !== PENDING_NOM_LOWER)
                            .forEach(p => {
                                puestoCounts.set(p.puesto, (puestoCounts.get(p.puesto) || 0) + 1);
                            });

                        if (puestoCounts.size === 0) return "No hay puestos registrados con personal asignado (aparte de los pendientes).";
                        
                        const sortedPuestos = Array.from(puestoCounts.entries()).sort((a, b) => a[0].localeCompare(b[0]));
                        const list = sortedPuestos.map(([puesto, count]) => `- ${puesto} (${count} persona${count > 1 ? 's' : ''})`).join('\n');
                        return `Estos son los puestos registrados con personal (${sortedPuestos.length}):\n${list}`;
                    }
                },
                // Fallback y manejo de ambig√ºedad
                {
                    name: "list_all_locations",
                    condition: (ni) => {
                        return checkKeywords(ni, 'lista') && 
                               (ni.includes("ubicacion") || ni.includes("ubicaciones") || 
                                ni.includes("base") || ni.includes("bases") ||
                                ni.includes("centro") || ni.includes("centros")) &&
                               ni.split(' ').length <= 4; // Para evitar falsos positivos en frases largas
                    },
                    action: (ni, ent) => {
                        if (allLocations.length === 0) return "No tengo informaci√≥n de ubicaciones disponibles.";
                        
                        // Ordenar las ubicaciones alfab√©ticamente
                        const sortedLocations = [...allLocations].sort((a, b) => 
                            a.nombre_centro.localeCompare(b.nombre_centro)
                        );
                        
                        // Formatear la lista de ubicaciones
                        const locationList = sortedLocations.map(loc => 
                            `- **${loc.nombre_centro}**`
                        ).join('\n');
                        
                        return `Estas son todas las ubicaciones disponibles (${sortedLocations.length}):\n${locationList}`;
                    }
                },
                {
                    name: "general_query_or_unknown",
                    condition: () => true, 
                    action: (ni, ent, ctx, originalInput) => {
                        if (ent.length > 1) {
                                            // Verificar si hay una ubicaci√≥n con coincidencia exacta de dos palabras
                            const locationEntities = ent.filter(e => e.type.startsWith('location_'));
                            if (locationEntities.length > 0) {
                                // Filtrar palabras comunes de la entrada del usuario
                                const inputWords = ni.split(' ')
                                    .filter(w => w.length > 0 && !COMMON_WORDS.has(w.toLowerCase()));
                                    
                                const exactMatch = locationEntities.find(loc => {
                                    // Filtrar palabras comunes del nombre de la ubicaci√≥n
                                    const locWords = normalize(loc.matchedKey, true)
                                        .split(' ')
                                        .filter(w => w.length > 0 && !COMMON_WORDS.has(w.toLowerCase()));
                                        
                                    // Verificar si todas las palabras de la consulta (sin comunes) est√°n en la ubicaci√≥n
                                    return inputWords.length > 0 && 
                                           inputWords.every(word => 
                                               locWords.some(locWord => locWord === word)
                                           );
                                });
                                
                                if (exactMatch) {
                                    conversationContext.lastLocation = exactMatch.data;
                                    return formatLocationInfo(exactMatch.data, 'full');
                                }
                            }
                            
                            const persons = ent.filter(e => e.type.startsWith('person_') && e.type !== 'person_pending');
                            
                            if (persons.length > 1) {
                                // Primero buscar coincidencia exacta con el nombre completo
                                const exactMatch = persons.find(p => {
                                    const normFullName = normalize(p.data.nombre, true);
                                    return normFullName === ni || p.matchedKey === ni;
                                });
                                
                                if (exactMatch) {
                                    conversationContext.lastPerson = exactMatch.data;
                                    conversationContext.lastLocation = null; 
                                    conversationContext.lastPuesto = null;
                                    return formatPersonInfo(exactMatch.data);
                                }
                                
                                // Funci√≥n de puntuaci√≥n para ordenar coincidencias
                                const score = (pEntity, query) => {
                                    let s = 0;
                                    const normFullName = normalize(pEntity.data.nombre, true);
                                    const queryWords = query.split(' ').filter(w => w.length > 2); // Palabras de m√°s de 2 letras
                                    const fullNameParts = normFullName.split(' ');
                                    const originalQuery = query;
                                    
                                    // Puntuaci√≥n m√°s alta para coincidencia exacta de nombre completo
                                    if (normFullName === query || pEntity.matchedKey === query) {
                                        return 1000 + pEntity.length * 10;
                                    }
                                    
                                    // Si la consulta incluye "tel√©fono de" o similar, priorizar la coincidencia exacta del nombre
                                    if (originalInputString && (originalInputString.includes('tel√©fono de') || 
                                                               originalInputString.includes('telefono de') ||
                                                               originalInputString.includes('tel√©fono del') ||
                                                               originalInputString.includes('telefono del'))) {
                                        // Extraer solo el nombre de la consulta
                                        const nameQuery = originalInputString.replace(/(tel[√©e]fono de(l)?|tel[√©e]fono|telefono|telfono|telf|tlf|m√≥vil|movil|celular|llamar|contactar|contacto|numero|n√∫mero)/gi, '').trim();
                                        const normNameQuery = normalize(nameQuery, true);
                                        
                                        // Si el nombre coincide exactamente, m√°xima prioridad
                                        if (normFullName === normNameQuery) {
                                            return 2000;
                                        }
                                        
                                        // Si la consulta est√° contenida en el nombre completo, priorizar
                                        if (normFullName.includes(normNameQuery) && normNameQuery.split(' ').length >= 2) {
                                            return 1500 + (normNameQuery.split(' ').length * 100);
                                        }
                                    }
                                    
                                    // Manejar b√∫squeda de "Iv√°n de la Paz"
                                    if (queryWords.length >= 3) {
                                        // Verificar si la consulta coincide con el inicio del nombre completo
                                        const queryStart = queryWords.join(' ');
                                        if (normFullName.startsWith(queryStart)) {
                                            return 800 + (queryWords.length * 30);
                                        }
                                        
                                        // Verificar si la consulta coincide con nombre + primer apellido compuesto
                                        const firstName = fullNameParts[0];
                                        const firstLastName = fullNameParts[1];
                                        const secondLastName = fullNameParts.length > 2 ? fullNameParts[2] : '';
                                        
                                        // Verificar coincidencia de nombre + apellido compuesto (ej: "Iv√°n de la Paz")
                                        if (queryWords[0] === firstName) {
                                            // Caso 1: Nombre + Apellido compuesto (ej: "Iv√°n de la")
                                            if (queryWords.length >= 2 && `${queryWords[1]} ${queryWords[2] || ''}`.trim() === firstLastName) {
                                                return 1200;
                                            }
                                            // Caso 2: Nombre + Primer apellido (ej: "Iv√°n de")
                                            if (queryWords[1] === firstLastName.split(' ')[0]) {
                                                return 1000;
                                            }
                                        }
                                    }
                                    
                                    // Puntos por cada palabra de la consulta que coincida
                                    const matchedWords = queryWords.filter(word => 
                                        normFullName.includes(word) || pEntity.matchedKey.includes(word)
                                    ).length;
                                    
                                    s += matchedWords * 20; // Puntos por palabras coincidentes
                                    
                                    // Bonus por tipo de coincidencia
                                    if (pEntity.type === 'person_full') s += 40;
                                    else if (pEntity.type === 'person_name_two_lastnames' || pEntity.type === 'person_name_first_compound_lastname') s += 30;
                                    else if (pEntity.type === 'person_name_firstlastname') s += 20;
                                    else if (pEntity.type === 'person_all_lastnames') s += 15;
                                    
                                    // Bonus por posici√≥n de la coincidencia (mejor al principio)
                                    if (normFullName.startsWith(query)) s += 60;
                                    
                                    // Bonus por longitud del nombre (prefiere nombres m√°s largos para evitar coincidencias parciales)
                                    s += pEntity.length * 5;
                                    
                                    // Bonus adicional si la consulta contiene "de la" o similar
                                    if (query.includes(' de la ') || query.includes(' del ') || query.includes(' de ')) {
                                        s += 50;
                                    }
                                    
                                    return s;
                                };
                                
                                // Ordenar por puntuaci√≥n
                                const sortedPersons = [...persons].sort((a,b) => score(b, ni) - score(a, ni));

                                const bestPersonMatch = sortedPersons[0];
                                const secondBestMatch = sortedPersons[1];
                                
                                // Calcular puntuaciones para determinar si hay un ganador claro
                                const scoreBest = score(bestPersonMatch, ni);
                                const scoreSecond = secondBestMatch ? score(secondBestMatch, ni) : 0;
                                const scoreDifference = scoreBest - scoreSecond;
                                
                                // Si la diferencia es significativa, considerar que hay un ganador claro
                                const isClearWinner = scoreDifference > 20 || 
                                                    (bestPersonMatch.matchedKey === ni && bestPersonMatch.length >= 2) ||
                                                    (normalize(bestPersonMatch.data.nombre, true) === ni);


                                if (isClearWinner) {
                                    conversationContext.lastPerson = bestPersonMatch.data;
                                    conversationContext.lastLocation = null; conversationContext.lastPuesto = null;
                                    return formatPersonInfo(bestPersonMatch.data);
                                }
                                
                                if (ni.split(' ').length === 1 && !checkKeywords(ni, 'lista')) {
                                    let commonMatch = true;
                                    for(const pEntity of persons) {
                                        const normFullName = normalize(pEntity.data.nombre, true);
                                        if (!normFullName.includes(ni)) {
                                            commonMatch = false; break;
                                        }
                                    }
                                    if (commonMatch) {
                                        let response = `He encontrado ${persons.length} personas que incluyen "**${originalInput || ni}**" en su nombre:\n`;
                                        response += persons.slice(0,5).map(p => `  - **${p.data.nombre}** (${p.data.puesto || 'N/A'})`).join('\n');
                                        if(persons.length > 5) response += "\n  ... y m√°s."
                                        response += "\nPor favor, proporciona un nombre m√°s completo o m√°s detalles.";
                                        return response;
                                    }
                                }
                            } 

                            let responseParts = ["He encontrado varias cosas relacionadas (demasiado ambiguo):"];
                            let addedToResponse = new Set();
                            ent.slice(0,3).forEach(e => { 
                                const dataSignature = JSON.stringify(e.data);
                                if (!addedToResponse.has(dataSignature)) { 
                                    if (e.type.startsWith('person_')) responseParts.push(`  - Persona: **${e.data.nombre}** (match: '${e.matchedKey}')`);
                                    else if (e.type.startsWith('location_')) responseParts.push(`  - Ubicaci√≥n: **${e.data.nombre_centro}** (match: '${e.matchedKey}')`);
                                    else if (e.type.startsWith('puesto_')) responseParts.push(`  - Puesto: **${e.data.nombre_puesto || e.originalKey}** (match: '${e.matchedKey}')`);
                                    addedToResponse.add(dataSignature);
                                }
                            });
                            if (responseParts.length > 1 && addedToResponse.size > 1) {
                                responseParts.push("Por favor, s√© m√°s espec√≠fico o pregunta por una sola cosa a la vez.");
                                return responseParts.join('\n');
                            } else if (ent.length > 0 && addedToResponse.size === 1) { 
                                const singleEntity = ent.find(e => JSON.stringify(e.data) === Array.from(addedToResponse)[0]);
                                 if (singleEntity.type.startsWith('person_')) { conversationContext.lastPerson = singleEntity.data; return formatPersonInfo(singleEntity.data); }
                                 if (singleEntity.type.startsWith('location_')) { conversationContext.lastLocation = singleEntity.data; return formatLocationInfo(singleEntity.data); }
                                 if (singleEntity.type.startsWith('puesto_')) { conversationContext.lastPuesto = singleEntity.data; return getIntentResponse(ni, [singleEntity], 'find_person_by_role', originalInput);}
                            }
                        }
                        
                        if (ent.length === 1) {
                            const singleEntity = ent[0];
                             if (singleEntity.type.startsWith('person_')) { conversationContext.lastPerson = singleEntity.data; return formatPersonInfo(singleEntity.data); }
                             if (singleEntity.type.startsWith('location_')) { conversationContext.lastLocation = singleEntity.data; return formatLocationInfo(singleEntity.data); }
                             if (singleEntity.type.startsWith('puesto_')) { conversationContext.lastPuesto = singleEntity.data; return getIntentResponse(ni, [singleEntity], 'find_person_by_role', originalInput);}
                        }
                        
                        return 'Lo siento, no he entendido bien tu pregunta. Prueba a reformularla o escribe "ayuda".';
                    }
                }
            ];
        }
        
        function getIntentResponse(normalizedInput, entities, specificIntent, originalInput) {
            if (specificIntent === 'find_person_by_role') {
                const puestosEntities = entities.filter(e => e.type.startsWith('puesto_') || e.type.startsWith('puesto_alias'));
                let targetPuestoNorm = '';
                let originalPuestoQuery = '';
                
                const mainPuestoEntity = puestosEntities.find(pe => (pe.type === 'puesto_general' || pe.type === 'puesto_explicit' || pe.type === 'puesto_alias') && pe.matchType === 'exact_phrase') || 
                                        puestosEntities.find(pe => pe.type === 'puesto_variant' && pe.matchType === 'exact_phrase') ||
                                        puestosEntities.find(pe => pe.type === 'puesto_explicit' || pe.type === 'puesto_alias') ||
                                        puestosEntities.find(pe => pe.type === 'puesto_general') ||
                                        (puestosEntities.length > 0 ? puestosEntities[0] : null);

                if (mainPuestoEntity) {
                    targetPuestoNorm = normalize(mainPuestoEntity.data.nombre_puesto || mainPuestoEntity.originalKey, true);
                    originalPuestoQuery = mainPuestoEntity.data.nombre_puesto || mainPuestoEntity.originalKey;
                } else { 
                    for (const role of (CONFIG_INTENT_SYNONYMS.puesto || [])) {
                        const normRole = normalize(role);
                        const questionPhrases = ["que hace", "qu√© hace", "a que se dedica", "a qu√© se dedica"];
                        if (normalizedInput.includes(normRole) && !questionPhrases.some(qp => normRole.includes(qp))) {
                            targetPuestoNorm = normRole; originalPuestoQuery = role; break;
                        }
                    }
                }

                if (targetPuestoNorm) {
                    const peopleWithRole = allPersons.filter(p => 
                        p.puesto && normalize(p.puesto, true).includes(targetPuestoNorm) && 
                        p.nombre.toLowerCase() !== PENDING_NOM_LOWER
                    );
                    if (peopleWithRole.length > 0) {
                        const displayPuesto = originalPuestoQuery || (peopleWithRole[0] ? peopleWithRole[0].puesto : targetPuestoNorm); 
                        if (peopleWithRole.length === 1 && (checkKeywords(normalizedInput, 'quien_es') || (mainPuestoEntity && normalizedInput === normalize(mainPuestoEntity.originalKey, true)))) {
                            conversationContext.lastPerson = peopleWithRole[0]; 
                            conversationContext.lastPuesto = null;
                            return `El/La **${displayPuesto}** es ${formatPersonInfo(peopleWithRole[0])}`;
                        }
                        const list = peopleWithRole.map(p => `- **${p.nombre}** (${p.ubicacion})`).join('\n');
                        return `Personas con el puesto de **${displayPuesto}** (o similar):\n${list}`;
                    }
                    return `No encontr√© a nadie con el puesto "${originalPuestoQuery || targetPuestoNorm}" o est√° pendiente de nombramiento.`;
                }
                return "No pude identificar un puesto espec√≠fico. Intenta 'Qui√©n es el Jefe de √Årea' o 'lista de puestos'.";
            }
            return 'Error interno: Intenci√≥n espec√≠fica no manejada: ' + specificIntent;
        }


        function processInput(originalInputString) {
            try {
                const normalizedInput = normalize(originalInputString);
                let entities = findEntities(normalizedInput); 
                
                console.log("Input:", originalInputString, "Normalized:", normalizedInput, "Entities:", entities.map(e => ({type: e.type, key: e.matchedKey, data_orig: e.originalKey, data_name: e.data.nombre || e.data.nombre_centro || e.data.puesto, length: e.length, rel: e.relevance?.toFixed(2) })));

                for (const rule of intentionRules) {
                    if (rule.condition(normalizedInput, entities, conversationContext, originalInputString)) {
                        console.log(`Intenci√≥n detectada: ${rule.name}`);
                        if (!checkKeywords(normalizedInput, 'y_su') && !checkKeywords(normalizedInput, 'solo_eso', true)) {
                            if (rule.name !== "context_acknowledged" && !rule.name.startsWith("context_")) {
                                if (!rule.name.startsWith("get_person_") && 
                                    !rule.name.startsWith("get_location_") && 
                                    !rule.name.startsWith("find_person_by_role_direct") &&
                                    !rule.name.startsWith("find_person_by_phone") && // No limpiar para b√∫squeda por tel√©fono
                                    rule.name !== "general_query_or_unknown" 
                                   ) {
                                     conversationContext.clear();
                                }
                            }
                        }
                        const response = rule.action(normalizedInput, entities, conversationContext, originalInputString); 
                        return response;
                    }
                }
                return 'Lo siento, no pude procesar tu solicitud (ninguna regla coincidi√≥). Intenta reformularla.';
            } catch (error) {
                console.error("Error al procesar la entrada:", error, error.stack);
                return `¬°Ups! Algo sali√≥ mal: "${error.message}". Intenta de nuevo.`;
            }
        }

        function formatPersonInfo(person, requestedInfo = 'full') {
            if (!person || !person.nombre) {
                return "No se encontr√≥ informaci√≥n de la persona solicitada.";
            }
            const isPteNombre = person.nombre.toLowerCase() === PENDING_NOM_LOWER;
            const isPtePuesto = person.puesto && person.puesto.toLowerCase() === PENDING_NOM_LOWER;

            if (isPteNombre && isPtePuesto) {
                 const ubicacionInfo = person.ubicacion ? ` en ${person.ubicacion}` : '';
                return `Hay un puesto actualmente **pendiente de nombramiento**${ubicacionInfo}. No se especifica el rol.`;
            }
            if (isPteNombre) {
                 return `Hay un puesto de **${person.puesto}** actualmente **pendiente de nombramiento** en ${person.ubicacion}.`;
            }

            let info = [];
            const addInfo = (label, value) => {
                if (value && value.toLowerCase() !== PENDING_NOM_LOWER) info.push(`${label}: ${value}`);
                else if (value && value.toLowerCase() === PENDING_NOM_LOWER && (requestedInfo ==='full' || label.toLowerCase() === requestedInfo )) info.push(`${label}: **Pendiente**`);
            };
            
            let title = `**${person.nombre}**`;

            if (requestedInfo === 'full' || requestedInfo === 'puesto') addInfo('Puesto', person.puesto);
            if (requestedInfo === 'full' || requestedInfo === 'ubicacion') addInfo('Ubicaci√≥n', person.ubicacion);
            if (requestedInfo === 'full' || requestedInfo === 'correo') addInfo('Correo', person.correo);
            if (requestedInfo === 'full' || requestedInfo === 'telefono') addInfo('Tel√©fono', person.telefono);
            
            if (info.length === 0) {
                const specificDataField = requestedInfo.toLowerCase();
                const specificDataValue = person[specificDataField]; 
                if (requestedInfo !== 'full' && specificDataValue && specificDataValue.toLowerCase() === PENDING_NOM_LOWER) {
                    return `La informaci√≥n de "${requestedInfo}" para **${person.nombre}** est√° **pendiente**.`;
                }
                if (requestedInfo !== 'full') {
                    return `No tengo informaci√≥n sobre "${requestedInfo}" para **${person.nombre}** o est√° pendiente.`;
                }
                if (requestedInfo === 'full' && Object.values(person).every(val => typeof val === 'string' && val.toLowerCase() === PENDING_NOM_LOWER || val === person.nombre || val === person.ubicacion)) {
                     return `**${person.nombre}**: Toda la informaci√≥n de contacto y puesto est√° actualmente **pendiente**. Se encuentra en ${person.ubicacion}.`;
                }
                return `No tengo m√°s detalles para **${person.nombre}** en este momento.`;
            }
            return title + (info.length > 0 ? ':\n  ' + info.join('\n  ') : '.');
        }

        function formatLocationInfo(location, requestedInfo = 'full') { 
             if (!location || !location.nombre_centro) {
                return "No se encontr√≥ informaci√≥n de la ubicaci√≥n solicitada.";
            }
            let parts = [`Informaci√≥n sobre **${location.nombre_centro}**:`];
            let infoFound = false;

            if (requestedInfo === 'full' || requestedInfo === 'ambitos') {
                if (location.ambitos_mantenimiento && location.ambitos_mantenimiento.length > 0) {
                    parts.push(`  √Åmbito de mantenimiento:\n    - ${location.ambitos_mantenimiento.join('\n    - ')}`);
                    infoFound = true;
                } else if (requestedInfo === 'ambitos') {
                     parts.push(`  No tengo informaci√≥n sobre el √°mbito de mantenimiento.`);
                     infoFound = true; 
                }
            }
            if (requestedInfo === 'full' || requestedInfo === 'personas') {
                 const peopleInLoc = allPersons.filter(p => p.ubicacion === location.nombre_centro && (p.nombre && p.nombre.toLowerCase() !== PENDING_NOM_LOWER));
                const ptePeopleInLoc = allPersons.filter(p => p.ubicacion === location.nombre_centro && (p.nombre && p.nombre.toLowerCase() === PENDING_NOM_LOWER));

                if (peopleInLoc.length > 0) {
                    // Ordenar para que el Jefe de Base aparezca primero
                    const sortedPeople = [...peopleInLoc].sort((a, b) => {
                        const isAJefe = a.puesto && a.puesto.toLowerCase().includes('jefe de base') ? -1 : 1;
                        const isBJefe = b.puesto && b.puesto.toLowerCase().includes('jefe de base') ? -1 : 1;
                        return isAJefe - isBJefe;
                    });
                    
                    const list = sortedPeople.map(p => `    - **${p.nombre}** (${p.puesto && p.puesto.toLowerCase() !== PENDING_NOM_LOWER ? p.puesto : 'Puesto pendiente'})`).join('\n');
                    parts.push(`  Personal asignado (${peopleInLoc.length}):\n${list}`);
                    infoFound = true;
                }
                
                if (ptePeopleInLoc.length > 0) {
                    const pteList = ptePeopleInLoc.map(p => `    - **${p.puesto !== PENDING_NOM_LOWER ? p.puesto : 'Rol sin especificar'}** (Pendiente de nombramiento)`).join('\n');
                    parts.push(`  Puestos pendientes de nombramiento (${ptePeopleInLoc.length}):\n${pteList}`);
                    infoFound = true;
                }
                
                if (peopleInLoc.length === 0 && ptePeopleInLoc.length === 0 && requestedInfo === 'personas') {
                     parts.push(`  No encontr√© personal asignado ni pendiente en esta ubicaci√≥n.`);
                     infoFound = true; 
                }
            }
            if (requestedInfo === 'full' || requestedInfo === 'direccion') {
                 if (location.direccion) {
                    parts.push(`  Direcci√≥n: ${location.direccion}`);
                    infoFound = true;
                 } else if (requestedInfo === 'direccion') {
                    parts.push(`  Direcci√≥n: No disponible.`);
                    infoFound = true; 
                 }
                 if (location.enlace_google_maps) {
                    parts.push(`  Google Maps: <a href="${location.enlace_google_maps}" target="_blank" class="text-blue-600 hover:underline">${location.enlace_google_maps}</a>`);
                    infoFound = true;
                 }
            }
            if (!infoFound && requestedInfo === 'full') parts.push("  No tengo m√°s detalles espec√≠ficos para esta ubicaci√≥n.");
            else if (!infoFound && requestedInfo !== 'full') return `No tengo informaci√≥n sobre "${requestedInfo}" para **${location.nombre_centro}**.`;
            
            return parts.join('\n');
        }
        
        function appendMessage(sender, text) {
            const messageWrapper = document.createElement('div');
            messageWrapper.classList.add('message-wrapper', sender === 'user' ? 'user-message-wrapper' : 'bot-message-wrapper');

            const avatarElement = document.createElement('div');
            avatarElement.classList.add('message-avatar', 'flex', 'items-center', 'justify-center', 'text-2xl', 'bg-gray-200', 'rounded-full');
            avatarElement.textContent = sender === 'user' ? USER_AVATAR_EMOJI : BOT_AVATAR_EMOJI;

            const messageContentDiv = document.createElement('div');
            messageContentDiv.classList.add('message-content');
            
            let htmlText = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); 
            htmlText = htmlText.replace(/\n/g, '<br>'); 
            htmlText = htmlText.replace(/(https?:\/\/(?:www\.)?google\.com\/maps\S+|https?:\/\/maps\.app\.goo\.gl\/\S+)/g, '<a href="$1" target="_blank" class="text-blue-600 hover:underline">$1</a>');
            
            messageContentDiv.innerHTML = htmlText;

            if (sender === 'user') {
                messageWrapper.appendChild(messageContentDiv);
                messageWrapper.appendChild(avatarElement);
            } else {
                messageWrapper.appendChild(avatarElement);
                messageWrapper.appendChild(messageContentDiv);
            }
            
            chatBox.appendChild(messageWrapper);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        function showTypingIndicator() { 
            if (!isTyping) {
                const typingWrapper = document.createElement('div');
                typingWrapper.classList.add('message-wrapper', 'bot-message-wrapper');
                typingWrapper.id = 'typingIndicatorWrapper'; 
                const avatarDiv = document.createElement('div');
                avatarDiv.classList.add('message-avatar', 'flex', 'items-center', 'justify-center', 'text-2xl', 'bg-gray-200', 'rounded-full');
                avatarDiv.textContent = BOT_AVATAR_EMOJI;
                typingWrapper.appendChild(avatarDiv);
                typingWrapper.appendChild(typingIndicatorElement); 
                
                chatBox.appendChild(typingWrapper);
                chatBox.scrollTop = chatBox.scrollHeight;
                isTyping = true;
            }
        }
        function hideTypingIndicator() { 
            const typingWrapper = document.getElementById('typingIndicatorWrapper');
            if (isTyping && typingWrapper) { 
                if (typingWrapper.parentNode === chatBox) { 
                    chatBox.removeChild(typingWrapper); 
                }
                isTyping = false;
            }
        }

        function displayHelpBubbles() {
            helpBubblesContainer.innerHTML = '';
            const helpQuestions = [
                "Tel√©fono de Mario Garc√≠a Aguado", "Correo de Javier Gambin", "y su ubicacion", 
                "Puesto de Lourdes Mirasierra", "Ubicaci√≥n de Esther Lorente", "Qui√©n es Garc√≠a Aguado",
                "Qui√©n es el Jefe de √Årea", "Personas en BM Villarrubia", "Personal de Madrid Sur", "Paz Notario",
                "√Åmbito de BM Gabald√≥n", "Direcci√≥n de BM Requena", "Jefe de Base en Monforte", "Madrid Sur direccion",
                "Lista de T√©cnicos de Energ√≠a", "Lista de todas las ubicaciones",
                "Lista de todos los puestos", "¬øQu√© hace Samuel Garc√≠a Chaparro?", "Informaci√≥n de Gambin Ortu√±o",
                "¬øQui√©nes son los Operadores CSI en CRC Albacete?", "Operadores CSI", "Telemando",
                "Contacto de PTE NOMBRAMIENTO en BM Villarrubia", "Lista de PTE NOMBRAMIENTO",
                "¬øHay alg√∫n T√©cnico II.SS.?", "ubicaci√≥n Iv√°n de la Paz", "610165651",
                "Informacion sobre Madrid Sur", "Madrid Sur ambito", 
                "¬øQu√© base tiene m√°s personal?", "¬øHay m√°s T√©cnicos de Energ√≠a o T√©cnicos II.SS.?"
            ];
            helpQuestions.sort(() => Math.random() - 0.5); 
            helpQuestions.slice(0, 12).forEach(question => { // Aumentado a 12
                const bubble = document.createElement('span');
                bubble.classList.add('help-bubble', 'px-3', 'py-1', 'bg-blue-100', 'border', 'border-blue-300', 'text-blue-800', 'rounded-full', 'cursor-pointer');
                bubble.textContent = question;
                bubble.addEventListener('click', () => {
                    userInput.value = question;
                    hideHelpBubbles();
                    handleUserInput(); 
                });
                helpBubblesContainer.appendChild(bubble);
            });
            helpBubblesContainer.classList.remove('hidden');
         }
        function hideHelpBubbles() { 
             helpBubblesContainer.classList.add('hidden');
        }
        
        function clearChat() {
            chatBox.innerHTML = '';
            appendMessage('bot', INITIAL_BOT_MESSAGE);
            conversationContext.clear();
            hideHelpBubbles();
            if(dataLoaded) userInput.focus();
        }

        helpButton.addEventListener('click', () => {
            if (!userInput.disabled) {
                userInput.value = 'ayuda';
                handleUserInput();
            }
        });

        async function handleUserInput() {
            if (!dataLoaded) {
                appendMessage('bot', 'Los datos a√∫n no est√°n cargados. Por favor, espera.');
                return;
            }
            const input = userInput.value.trim(); 
            if (!input) return;

            appendMessage('user', input); 
            userInput.value = '';
            hideHelpBubbles();
            showTypingIndicator();

            setTimeout(() => {
                const botResponse = processInput(input); 
                hideTypingIndicator();
                appendMessage('bot', botResponse);
            }, Math.random() * 300 + 150); 
        }

        sendButton.addEventListener('click', handleUserInput);
        userInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleUserInput();
            }
        });
        clearChatButton.addEventListener('click', clearChat);
        
        defineIntentionRules();
        loadData();

    </script>
</body>
</html>